!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-equiv" => "Content-Type"}/
    / Slide meta data, remove/edit as you see fit
    %title OpenFlow platform Trema, hands-on session
    %meta{:content => "Yasuhito Takamiya", :name => "author"}/
    %meta{:content => "yasuhito@gmail.com", :name => "email"}/
    %meta{:content => "November 9, 2011", :name => "date"}/
    / Slippy core file and dependencies
    %script{:src => "slippy/src/jquery.min.js", :type => "text/javascript"}
    %script{:src => "slippy/src/jquery.history.js", :type => "text/javascript"}
    %script{:src => "slippy/src/slippy.js", :type => "text/javascript"}
    / Slippy structural styles
    %link{:href => "slippy/src/slippy.css", :rel => "stylesheet", :type => "text/css"}/
    / Trema theme
    %link{:href => "trema.css", :rel => "stylesheet", :type => "text/css"}/
    / Syntax highlighting core file
    %script{:src => "slippy/src/highlighter/shCore.js", :type => "text/javascript"}
    / Syntax highlighting brushes, remove those you don't need
    %script{:src => "slippy/src/highlighter/shBrushBash.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushCpp.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushCSharp.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushCss.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushDelphi.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushDiff.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushGroovy.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushJava.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushJScript.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushPhp.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushPlain.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushPython.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushRuby.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushScala.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushSql.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushVb.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushXml.js", :type => "text/javascript"}
    / Syntax highlighting styles
    %link{:href => "slippy/src/highlighter/shCore.css", :rel => "stylesheet", :type => "text/css"}/
    %link{:href => "slippy/src/highlighter/shThemeDefault.css", :rel => "stylesheet", :type => "text/css"}/
    / Slippy init code
    :javascript
      $(function() {
          $(".slide").slippy({
              // settings go here
              // possible values are:
              //  - animLen, duration for default animations (0 = disabled)
              //  - animInForward, receives a slide and animates it
              //  - animInRewind, receives a slide and animates it
              //  - animOutForward, receives a slide and animates it
              //  - animOutRewind, receives a slide and animates it
              //  - baseWidth, defines the base for img resizing, if you don't want only
              //    full-width images, specify this as the pixel width of a slide so that
              //    images are scaled properly (default is 620px wide)
              //  - ratio, defines the width/height ratio of the slides, defaults to 1.3 (620x476)
              //  - margin, the fraction of screen to use as slide margin, defaults to 0.15
          });
          SyntaxHighlighter.all();
      });
    / Custom style for this deck
    :css
      .slide.nofooter {
        border: 0;
        background: 0;
      }
  %body


    .slide
      .vcenter
        %h2 OpenFlow platform Trema
        %h2 Hands-on session
        %br
        %br
        %br
        %p
          Hideyuki Shimonishi
          %a{:href => "http://twitter.com/hide_shimonishi"} @hide_shimonishi
          %br
          Yasuhito Takamiya
          %a{:href => "http://twitter.com/yasuhito"} @yasuhito
          %br
          Kazushi Sugyo
          %br
          NEC
          %br
          %br
          %p CHANGE & OFELIA Summer School
          %p November 9, 2011


    .slide
      %h1 Agenda
      %ul
        %li Introduction and design condept
        %li Hands-on coding
        %li Summary


    .slide
      %h1 We are...
      %p Trema team from NEC laboratories
      %ul
        %li Hideyuki (Networking Ninja)
        %li Yasuhito (HPC and Middleware)
        %li Kazushi (KAME: IPv6 stack for *BSD)


    .slide
      %h1 Q: Why Framework?
      %p
        %b A: High productivity (e.g., Rails)
      %ul
        %li "common operations" can be written in short
        %li Full-stack: develop with your laptop
        %li Tight loops of "coding, testing, and debugging"
      %br
      %p
        %span{:style => "background-color: #ffff00"} ...And there were no such programming framework in OpenFlow yet.


    .slide
      %h1 Features of Trema Framework
      %p
        %span{:style => "background-color: #ffff00"} Most "modern" framework for OpenFlow
      %ul
        %li Ruby or C (Ruby's productivity + C's speed)
        %li Full-stack: develop with your laptop
        %li Open development process on github (GPL2)


    .slide
      %h1 Voices from Exparts
      %p
        %i "I poked through Trema recently.  It looks like a *great* project. Very clean."
        %i (openflow-discuss list)
      .right
        %p Martin Casado (Nicira CTO)


    .slide
      %h1 Trema Design Concept
      .vcenter
        %h1 "Write it short, run it quickly"


    .slide
      %h1 Trema Design Concept
      .vcenter
        %h1
          "
          %span{:style => "background-color: #ffff00"}Write it short,
          run it quickly"


    .slide
      %h1 Why short code?
      %p If you can keep your code short,
      %ul
        %li more quickly you can finish coding,
        %li less incidence of software bug,
        %li and easier to maintainance your code.

        
    .slide
      %h1 Example: Trema repeater-hub
      %pre{:class => "brush: ruby; highlight: [3, 8]"}
        :preserve
          class RepeaterHub < Controller
            def packet_in datapath_id, message
              send_flow_mod_add(
                datapath_id,
                :match => ExactMatch.from( message ),
                :actions => ActionOutput.new( OFPP_FLOOD )
              )
              send_packet_out(
                datapath_id,
                :packet_in => message,
                :actions => ActionOutput.new( OFPP_FLOOD )
              )
            end
          end
      %p
        Only needs essential methods in this code.
        %br
        (flow_mod then FLOOD)


    .slide
      %h1 Let's compare Trema with
      %ul
        %li NOX (Python binding)
        %li Beacon (Java)


    .slide
      %h1 NOX (Python binding)
      %p Redundant code!
      %pre{:class => "brush: python; highlight: [2, 8, 17]"}
        :preserve
          class pyswitch(Component):
              def __init__(self, ctxt):
                  global inst
                  Component.__init__(self, ctxt)
                  self.st = {}
                  inst = self

              def install(self):
                  inst.register_for_packet_in(packet_in_callback)
                  inst.register_for_datapath_leave(datapath_leave_callback)
                  inst.register_for_datapath_join(datapath_join_callback)
                  inst.post_callback(1, timer_callback)

              def getInterface(self):
                  return str(pyswitch)

              def getFactory():
                  class Factory:
                      def instance(self, ctxt):
                          return pyswitch(ctxt)
                  return Factory()


    .slide
      %h1 Beacon (Java)
      %p We dislike Java (static typing system WITHOUT good type inference mechanism makes your code looong!)
      %div{:align => "center"}
        %img{:src => "./static-typing.gif", :height => "60%"}/


    .slide
      %h1 Trema Design Concept
      .vcenter
        %h1
          "Write it short,
          %span{:style => "background-color: #ffff00"} run it quickly
          "


    .slide
      %h1 Pain of OpenFlow development
      %p
        %i "It is complicated to setup OpenFlow development environment (network configurations and VM installations etc.)"

      %br

      %p
        %i "I don't have a OpenFlow switch."

      %br

      %p
        %i "In the first place, I don't have a network usable for OpenFlow experiments."

      .right
        %p Anonymous programmer


    .slide
      %h1 Trema Works with No Pain
      %p
        You can build a virtual network on your laptop and test your own controllers on it.
      %ul
        %li Run your controller without modifications
        %li Send and receive test packets between virtual hosts
        %li Dump switch flow-tables etc.

      %br

      %p.right See how it works...
        

    .slide
      .vcenter
        %h1 Common work flow of development with Trema


    .slide
      %h1 Let's setup Trema!
      %pre.brush:.plain
        :preserve
          $ git clone git://github.com/trema/trema.git
          $ ./trema/build.rb
      %p And there are no step three!


    .slide
      %h1 It's Shakyo Time!

      %span.right
        %img{:src => "./shakyo.jpg", :height => "20%"}/

      %ul
        %li
          Open a file with your favorite editor and let's
          %b shyakyo
          the following code.
        %li Shyakyo = The Japanese form of sutra transcription
        %li Just type it as is ... don't think at first, the details are described later.

      %span.right
        %small The image was taken from http://bit.ly/tI6OXP


    .slide
      %h1 Syakyo #1: Your first controller
      %p Define a controller as a class and make it derived from Controller class
      %pre.brush:.ruby
        :preserve
          # simple.rb

          class SimpleController < Controller
          end
      %br

      %p Run it with "trema run" command:
      %pre.brush:.plain
        :preserve
          % ./trema run ./simple.rb


    .slide
      %h1 Syakyo #2: Hello Trema!
      %ul
        %li Add start method to the controller class.
        %li The method is a hook method invoked at startup (initializer).
      %pre{:class => "brush: ruby; highlight: [3,4,5]"}
        :preserve
          # hello.rb
          class HelloController < Controller
            def start
              puts "Hello, Trema!"
            end
          end

      %p Then you can run it with "trema run"
      %pre{:class => "brush: ruby; highlight: [2]"}
        :preserve
          % ./trema run ./hello.rb
          Hello, Trema!


    .slide
      %h1 Class in Ruby
      %pre.brush:.ruby
        :preserve
          class ClassName < SuperClassName
            def method_name arg1, arg2
              # method body
            end
          end


    .slide
      %h1 Syakyo #3: Switch Monitor
      %p Switch monitor controller spec:
      %ul
        %li Update the list of switches in real-time
        %li Notifies when a new switch is UP
        %li Notifies when a switch become DOWN


    .slide
      %h1 Syakyo #3: Switch Monitor
      %pre.brush:.ruby
        :preserve
          # src/examples/switch_monitor/switch-monitor.rb
          class SwitchMonitor < Controller
            periodic_timer_event :show_switches, 10

            def start
              @switches = []
            end

            def switch_ready datapath_id
              @switches << datapath_id.to_hex
              info "Switch \#{ datapath_id.to_hex } is UP"
            end

            def switch_disconnected datapath_id
              @switches -= [ datapath_id.to_hex ]
              info "Switch \#{ datapath_id.to_hex } is DOWN"
            end

            private

            def show_switches
              info "All switches = " + @switches.sort.join( ", " )
            end
          end


    .slide
      %h1 Event Handlers
      %pre{:class => "brush: ruby; highlight: [9,14]"}
        :preserve
          class SwitchMonitor < Controller
            periodic_timer_event :show_switches, 10

            def start
              @switches = []
            end

            def switch_ready datapath_id
              @switches << datapath_id.to_hex
              info "Switch \#{ datapath_id.to_hex } is UP"
            end

            def switch_disconnected datapath_id
              @switches -= [ datapath_id.to_hex ]
              info "Switch \#{ datapath_id.to_hex } is DOWN"
            end

            private

            def show_switches
              info "All switches = " + @switches.sort.join( ", " )
            end
          end


    .slide
      %h1 switch_ready handler
      %pre{:class => "brush: ruby; highlight: [8,9,10,11]"}
        :preserve
          class SwitchMonitor < Controller
            periodic_timer_event :show_switches, 10

            def start
              @switches = []
            end

            def switch_ready datapath_id
              @switches << datapath_id.to_hex
              info "Switch \#{ datapath_id.to_hex } is UP"
            end
      %ul
        %li When a switch is connected to the controller, add its dpid to the switch-list instance variable (@switches)
        %li Output like "Switch 0xabc is UP"


    .slide
      %h1 List in Ruby
      %pre.brush:.ruby
        :preserve
          % irb
          > zoo = []
          => []

          > zoo << "bat"
          => ["bat"]

          > zoo << "gnu"
          => ["bat", "gnu"]

          > zoo << "dog"
          => ["bat", "gnu", "dog"]

          > zoo -= ["bat"]
          => ["gnu", "dog"]

          > zoo.sort
          => ["dog", "gnu"]
      %p irb = interactive ruby (REPL)


    .slide
      %h1 Variable and String in Ruby
      %pre.brush:.ruby
        :preserve
          % irb
          > name = "Spider-Man"
          => "Spider-Man"

          > puts "My name is \#{ name }"
          My name is Spider-Man
          => nil


    .slide
      %h1 switch_disconnected handler
      %ul
        %li When a switch become DOWN, remove its dpid from @switches list
        %li Output like "Switch 0xabc is DOWN"
      %pre{:class => "brush: ruby; highlight: [6,7,8,9]"}
        :preserve
          # src/examples/switch_monitor/switch-monitor.rb
          class SwitchMonitor < Controller

              ...

            def switch_disconnected datapath_id
              @switches -= [ datapath_id.to_hex ]
              info "Switch \#{ datapath_id.to_hex } is DOWN"
            end

              ...



    .slide
      %h1 show_switches timer handler
      %ul
        %li Output the switch list like "All switches = 0xabc, 0xdef, ..." in every 10 seconds
        %li periodic_timer_handler registers show_switches method as a timer handler
      %pre{:class => "brush: ruby; highlight: [2,6,7,8]"} 
        :preserve
          class SwitchMonitor < Controller
            periodic_timer_event :show_switches, 10

              ...

            def show_switches
              info "All switches = " + @switches.sort.join( ", " )
            end
          end


    .slide
      %h1 Run Switch Monitor

      %p Write a virtual network configuration (DSL) that adds three switches to the network.
      %pre.brush:.ruby
        :preserve
          # switch-monitor.conf
          vswitch { datapath_id 0x1 }
          vswitch { datapath_id 0x2 }
          vswitch { datapath_id 0x3 }

      %p Then pass it to trema run with -c option
      %pre.brush:.plain
        :preserve
          % ./trema run ./switch-monitor.rb -c ./switch-monitor.conf
          Switch 0x3 is UP
          Switch 0x2 is UP
          Switch 0x1 is UP
          All switches = 0x1, 0x2, 0x3
          All switches = 0x1, 0x2, 0x3
          All switches = 0x1, 0x2, 0x3
            ...


    .slide
      %h1 Virtual Network DSL
      %ul
        %li You can build arbitrally network topology on your laptop and run your controlller on it.
        %li Debug your controller by sending and receiving test packets between virtual hosts.
        %li You can use virtual switch, host, and link to construct the virtual network.


    .slide
      %h1 Kill a Switch Intentionally

      %p Open another terminal and run "trema kill"
      %pre.brush:.bash
        :preserve
          % ./trema kill 0x3

      %p Then you can see "Switch 0x??? is DOWN" on the "trema run" terminal
      %pre{:class => "brush: ruby; highlight: [9]"} 
        :preserve
          % ./trema run ./switch-monitor.rb -c ./switch-monitor.conf
          Switch 0x3 is UP
          Switch 0x2 is UP
          Switch 0x1 is UP
          All switches = 0x1, 0x2, 0x3
          All switches = 0x1, 0x2, 0x3
          All switches = 0x1, 0x2, 0x3
            ...
          Switch 0x3 is DOWN


    .slide
      %h1 Summary: Switch Monitor
      %ul
        %li Implement the logic of a controller by defining event handler methods (e.g., switch_ready, switch_disconnected etc.)
        %li Network DSL makes it possible to test your own controller even if you don't have an OpenFlow switch.


    .slide
      %h1 Syakyo #4: packet-in handling
      %p Add the following method to handle packet-in
      %pre{:class => "brush: ruby; highlight: [2,3,4]"}
        :preserve
          class SimpleController < Controller
            def packet_in dpid, message
              puts "New packet_in message!"
            end
              ...
      %ul
        %li dpid: the datapath ID of the switch that received a packet-in
        %li message: packet-in message object


    .slide
      %h1 Let's Send Packets!
      %p Firstly, you must add virtual hosts to send/receive packets and connect them to a virtual switch:
      %pre.brush:.ruby
        :preserve
          vswitch { dpid 0xabc }

          # Add two virtual hosts
          vhost("host1") {
            mac "00:00:00:00:00:01"
          }
          vhost("host2") {
            mac "00:00:00:00:00:02"
          }

          # connect hosts to a switch
          link "0xabc", "host1"
          link "0xabc", "host2"


    .slide
      %h1 Let's Send Packets!
      %ul
        %li Send test packets with send_packets
        %li For example the following will send ten packets from host1 to host2
      %pre.brush:.plain
        :preserve
          % ./trema send_packets --source host1 --dest host2 --n_pkts 10 --pps 10
          New packet_in message!
          New packet_in message!
          New packet_in message!
          New packet_in message!
          New packet_in message!
          New packet_in message!
          New packet_in message!
          New packet_in message!
          New packet_in message!
          New packet_in message!
      %p packet_in handler is called ten times


    .slide
      %h1 Large-scale and complex topology
      %p Ten switches full-mesh topology configurations in flat (about 80 LOC)
      %pre.brush:.ruby
        :preserve
          vswitch { dpid "0x1" }
          vswitch { dpid "0x2" }
          vswitch { dpid "0x3" }
          vswitch { dpid "0x4" }
            ...

          link "0x1", "0x2"
          link "0x1", "0x3"
          link "0x1", "0x4"
          link "0x1", "0x5"
          link "0x1", "0x6"
          link "0x1", "0x7"
          link "0x1", "0x8"
          link "0x1", "0x9"
          link "0x1", "0x10"
          link "0x2", "0x3"
          link "0x2", "0x4"
            ...


    .slide
      %h1 Advanced DSL Usage
      %ul
        %li You can use full Ruby syntax in the DSL
        %li the full-mesh topology can be rewritten briefly with nested loops:
      %pre.brush:.ruby
        :preserve
          $nswitch = 10

          1.upto( $nswitch ).each do | sw1 |
            vswitch { dpid sw1.to_hex }

            1.upto( $nswitch ).each do | sw2 |
              link sw1.to_hex, sw2.to_hex if sw1 < sw2
            end
          end
      %p Very concise!


    .slide
      %h1 Syakyo #5: Modifying flow-table
      %p Write a flow-entry that forwards incoming packets to the next switch port
      %pre{:class => "brush: ruby; highlight: [3,4,5,6,7,8]"}
        :preserve
          class CbenchSwitch < Controller
            def packet_in dpid, message
              send_flow_mod_add(
                dpid,
                :match => ExactMatch.from( message ),
                :buffer_id => message.buffer_id,
                :actions => ActionOutput.new( message.in_port + 1 )
              )
            end
          end
      %p Very concise!


    .slide
      %h1 Comparison of flow_mod APIs

      %p Trema
      %pre.brush:.ruby
        :preserve
          send_flow_mod_add(
            dpid,
            :match => ExactMatch.from( message ),
            :buffer_id => message.buffer_id,
            :actions => ActionOutput.new( message.in_port + 1 )
          )

      %p NOX
      %pre.brush:.python
        :preserve
          inst.install_datapath_flow(
            dpid,
            extract_flow(packet),
            CACHE_TIMEOUT, 
            openflow.OFP_FLOW_PERMANENT,
            [[openflow.OFPAT_OUTPUT, [0, prt[0]]]],
            bufid,
            openflow.OFP_DEFAULT_PRIORITY,
            inport,
            buf
          )


    .slide
      %h1 Nifty API for Match Structure

      %p You can easily create an exact match from incoming packet_in message:

      %pre{:class => "brush: ruby; highlight: [3]"}
        :preserve
          send_flow_mod_add(
            dpid,
            :match => ExactMatch.from( message ),
            :buffer_id => message.buffer_id,
            :actions => ActionOutput.new( message.in_port + 1 )
          )

      %p This is equivalent with:

      %pre.brush:.ruby
        :preserve
          :match => Match.new(
            :in_port = message.in_port,
            :nw_src => message.nw_src,
            :nw_dst => message.nw_dst,
            :tp_src => message.tp_src,
            :tp_dst => message.tp_dst,
            :dl_src => message.dl_src,
              ...
          )


    .slide
      %h1 Run cbench benchmarks
      %p cbench = A controller benchmark that measures flow-setup/sec
      %pre.brush:.plain
        :preserve
          1   switches: fmods/sec:  10627   total = 10.626989 per ms 
          1   switches: fmods/sec:  8184   total = 8.183992 per ms 
          1   switches: fmods/sec:  7542   total = 7.541992 per ms 
          1   switches: fmods/sec:  7852   total = 7.851992 per ms 
          1   switches: fmods/sec:  8243   total = 8.242992 per ms 
          1   switches: fmods/sec:  7807   total = 7.806977 per ms 
          1   switches: fmods/sec:  8484   total = 8.483992 per ms 
          1   switches: fmods/sec:  8401   total = 8.400992 per ms 
          1   switches: fmods/sec:  8129   total = 8.128992 per ms 
          1   switches: fmods/sec:  7853   total = 7.852788 per ms 
          RESULT: 1 switches 9 tests min/max/avg/stdev = 7541.99/8483.99/8054.97/292.12 responses/s
      %p About 8,000 flow-setup/sec


    .slide
      %h1 cbench with C version controller
      %p About 14,000 flow-setup/sec
      %pre.brush:.plain
        :preserve
          1   switches: fmods/sec:  8891   total = 8.890991 per ms 
          1   switches: fmods/sec:  14864   total = 14.863985 per ms 
          1   switches: fmods/sec:  14316   total = 14.315986 per ms 
          1   switches: fmods/sec:  14548   total = 14.547985 per ms 
          1   switches: fmods/sec:  14648   total = 14.647956 per ms 
          1   switches: fmods/sec:  13318   total = 13.317987 per ms 
          1   switches: fmods/sec:  14376   total = 14.375986 per ms 
          1   switches: fmods/sec:  13143   total = 13.142987 per ms 
          1   switches: fmods/sec:  14275   total = 14.274986 per ms 
          1   switches: fmods/sec:  14280   total = 14.279986 per ms 
          RESULT: 1 switches 9 tests min/max/avg/stdev = 13142.99/14863.99/14196.43/549.16 responses/s
      %p We recommend to write a controller in Ruby at first, then rewrite them with C if need be


    .slide
      %h1 Traffic Monitor
      %ul
        %li A L2 switch
        %li Counts the number of packets sent by each user
        %li Each user is identified by its MAC address


    .slide
      %h1 Traffic Monitor classes
      %ul
        %li FDB class for learning MAC <=> switch-port pair
        %li Counter class that keeps number of packets sent by each user
        %li TrafficMonitor class that acts as a Controller


    .slide
      %h1 Syakyo #6: FDB Class
      %pre.brush:.ruby
        :preserve
          class FDB
            def initialize
              @db = {}
            end

            def lookup mac
              if @db[ mac ]
                @db[ mac ][ :port_number ]
              else
                nil
              end
            end

            def learn mac, port_number
              if @db[ mac ]
                @db[ mac ][ :port_number ] = port_number
              else
                @db[ mac ] = { :mac => mac, :port_number => port_number }
              end
            end
          end


    .slide
      %h1 FDB Class
      %pre.brush:.ruby
        :preserve
          % irb
          > require "fdb"
          => true

          > fdb = FDB.new
          => #&lt;FDB:0xb73591e0 @db={}>

          > fdb.lookup "00:00:00:00:00:01"
          => nil

          > fdb.learn "00:00:00:00:00:01", 1
          => {:mac=>"00:00:00:00:00:01", :port_number=>1}

          > fdb.lookup "00:00:00:00:00:01"
          => 1

          > fdb.learn "00:00:00:00:00:02", 2
          => {:mac=>"00:00:00:00:00:02", :port_number=>2}

          > fdb.lookup "00:00:00:00:00:02"
          => 2


    .slide
      %h1 Hash in Ruby
      %pre.brush:.ruby
        :preserve
          % irb
          > price = { "Mac" => 1000, "iPhone" => 500, "iPad" => 600 }
          => { "Mac" => 1000, "iPhone" => 500, "iPad" => 600 }

          > price[ "iPhone" ]
          => 500

          > price[ "iPad" ]
          => 600

          > price[ "iPod Touch" ]
          => nil

          > price[ "iPod Touch" ] = 300
          => 300

          > price[ "iPod Touch" ]
          => 300


    .slide
      %h1 Syakyo #7: Counter Class
      %pre.brush:.ruby
        :preserve
          class Counter
            def initialize
              @db = {}
            end

            def add mac, packet_count, byte_count
              @db[ mac ] ||= { :packet_count => 0, :byte_count => 0 }
              @db[ mac ][ :packet_count ] += packet_count
              @db[ mac ][ :byte_count ] += byte_count
            end

            def each_pair &block
              @db.each_pair &block
            end
          end


    .slide
      %h1 Counter Class
      %pre.brush:.ruby
        :preserve
          % irb
          > require "counter"
          => true

          > counter = Counter.new
          => #<Counter:0xb7366d2c @db={}>

          > counter.add "00:00:00:00:00:01", 1, 100
          => 100

          > counter.add "00:00:00:00:00:02", 1, 100
          => 100

          > counter.add "00:00:00:00:00:02", 1, 100
          => 200

          > counter.each_pair do | mac, counter |
          *   p counter
          > end
          {:packet_count=>1, :byte_count=>100}
          {:packet_count=>2, :byte_count=>200}
          => {"00:00:00:00:00:01"=>{:packet_count=>1, :byte_count=>100}, "00:00:00:00:00:02"=>{:packet_count=>2, :byte_count=>200}}


    .slide
      %h1 TrafficMonitor Class Overview
      %p TrafficMonitor has the following two handlers
      %ul
        %li packet_in: L2 switching. When a packet_in comes, learn MAC <=> switch-port pair and send flow_mod to a switch
        %li flow_removed: counts the number of packets and bytes from a user. This information is piggy-backed with flow_removed messages


    .slide
      %h1 Syakyo #8: TrafficMonitor#packet_in
      %pre{:class => "brush: ruby; highlight: [16,17,19]"}
        :preserve
          class TrafficMonitor < Controller
            periodic_timer_event :show_counter, 10

            def start
              @counter = Counter.new
              @fdb = FDB.new
            end

            def packet_in datapath_id, message
              macsa = message.macsa
              macda = message.macda

              @fdb.learn macsa, message.in_port
              out_port = @fdb.lookup( macda )
              if out_port
                flow_mod datapath_id, macsa, macda, out_port
                packet_out datapath_id, message, out_port
              else
                flood datapath_id, message
              end
            end
              ...


    .slide
      %h1 Syakyo #9: TrafficMonitor#flow_mod
      %pre{:class => "brush: ruby; highlight: [7]"}
        :preserve
            private
              ...
            def flow_mod datapath_id, macsa, macda, out_port
              send_flow_mod_add(
                datapath_id,
                :send_flow_rem => true,
                :hard_timeout => 10,
                :match => Match.new(
                  :dl_src => macsa.to_s,
                  :dl_dst => macda.to_s
                ),
                :actions => Trema::ActionOutput.new( out_port )
              )
            end
      %p :hard_timeout forces flow-entries to be removed in ten seconds and therefore causes flow_removed


    .slide
      %h1 Syakyo #10: TrafficMonitor#packet_out and flood
      %pre{:class => "brush: ruby; highlight: [9]"}
        :preserve

          class TrafficMonitor < Controller
              ...
            private
              ...
            def packet_out datapath_id, message, out_port
              send_packet_out(
                datapath_id,
                :packet_in => message,
                :actions => Trema::ActionOutput.new( out_port )
              )
            end

            def flood datapath_id, message
              packet_out datapath_id, message, OFPP_FLOOD
            end
          end


    .slide
      %h1 Syakyo #11: TrafficMonitor#flow_removed
      %pre.brush:.ruby
        :preserve
          class TrafficMonitor < Controller
            ...

          def flow_removed datapath_id, message
            @counter.add(
              message.match.dl_src,
              message.packet_count,
              message.byte_count
            )
          end


    .slide
      %h1 Run Traffic Monitor
      %p DSL
      %pre.brush:.ruby
        :preserve
          vswitch { dpid 0xabc }

          # Add two virtual hosts
          vhost("host1") {
            mac "00:00:00:00:00:01"
          }
          vhost("host2") {
            mac "00:00:00:00:00:02"
          }

          # connect hosts to a switch
          link "0xabc", "host1"
          link "0xabc", "host2"

      %p Run
      %pre.brush:.ruby
        :preserve
          % ./trema run ./traffic-monitor.rb -c ./traffic-monitor.conf


    .slide
      %h1 Let's Send Packets!
      %p Open a new terminal and send packets betweeen host1 and host2:
      %pre.brush:.bash
        :preserve
          % ./trema send_packets --source host1 --dest host2 --n_pkts 10 --pps 10
          % ./trema send_packets --source host2 --dest host1 --n_pkts 10 --pps 10
      %p Then the trema run terminal will look like:
      %pre.brush:.bash
        :preserve
            ...
          00:00:00:00:00:01 10 packets (640 bytes)
          00:00:00:00:00:02 10 packets (640 bytes)
            ...


    .slide
      %h1 Trema Sample Apps
      %ul
        %li Trema distribution includes various samples (in Ruby and C)
        %li We recommend to run them and read its source code
      %pre.brush:.plain
        :preserve
          % ls src/examples
          cbench_switch          dumper            hash_bench
          hello_trema            learning_switch   list_switches
          multi_learning_switch  openflow_message  packet_in
          repeater_hub           switch_info       switch_monitor
          traffic_monitor


    .slide
      %h1 trema/apps
      %p
        %a{:href => "https://github.com/trema/apps"}https://github.com/trema/apps
      %p "Nearly production-level" apps written in Trema
      %ul
        %li routing switch
        %li load balancer
        %li topology manager etc. etc...


    .slide
      %h1 Unit-Test
      %ul
        %li You can write unit-tests of send/receive packets between hosts and flow-table entries of switches etc. with RSpec
        %li The details can be found in spec/ directory


    .slide
      %h1 Unit-Test Example
      %pre.brush:.ruby
        :preserve
          describe RepeaterHub do
            around do | example |
              network {
                vswitch("switch") { datapath_id "0xabc" }
                vhost("host1") { promisc "on" }
                vhost("host2") { promisc "on" }
                link "switch", "host1"
                link "switch", "host2"
              }.run( RepeaterHub ) {
                example.run
              }
            end

            context "when host1 sends one packet to host2" do
              describe "switch" do
                before { send_packets "host1", "host2" }
                subject { switch( "switch" ) }
                it { should have( 1 ).flows }
                its( "flows.first.actions" ) { should == "FLOOD" }
              end

                ...


    .slide
      %h1 Summary
      %p
        %span{:style => "background-color: #ffff00"} OpenFlow frmework Trema
      %ul
        %li You can write controllers short and run it quickly
        %li Many examples in src/examples and trema/apps repository
        %li Pull-requests and bug-reports are welcome!


    .slide
      %h1 Meta
      %ul
        %li
          Trema HomePage
          %a{:href => "http://trema.github.com/trema/"} http://trema.github.com/trema/
        %li
          Ruby API Document:
          %a{:href => "http://rubydoc.info/github/trema/trema/"} http://rubydoc.info/github/trema/trema/
        %li
          Twitter Account:
          %a{:href => "http://twitter.com/trema_news"} @trema_news


    .layout{"data-name" => "default"}
      %content
      .footer
        %span.left
          %b Hideyuki Shimonishi, Yasuhito Takamiya, Kazushi Sugyo
        %span.right
          Trema on
          %a{:href => "http://github.com/trema/trema/"} github
        %span.left CHANGE & OFELIA Summer School 2011
        %span.right
          Twitter
          %a{:href => "http://twitter.com/trema_news"} @trema_news


    .layout.nofooter{"data-name" => "alt"}
      %content
