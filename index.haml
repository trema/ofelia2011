!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-equiv" => "Content-Type"}/
    / Slide meta data, remove/edit as you see fit
    %title OpenFlow Framework Trema, hands-on session
    %meta{:content => "Yasuhito Takamiya", :name => "author"}/
    %meta{:content => "yasuhito@gmail.com", :name => "email"}/
    %meta{:content => "November 9, 2011", :name => "date"}/
    / Slippy core file and dependencies
    %script{:src => "slippy/src/jquery.min.js", :type => "text/javascript"}
    %script{:src => "slippy/src/jquery.history.js", :type => "text/javascript"}
    %script{:src => "slippy/src/slippy.js", :type => "text/javascript"}
    / Slippy structural styles
    %link{:href => "slippy/src/slippy.css", :rel => "stylesheet", :type => "text/css"}/
    / Trema theme
    %link{:href => "trema.css", :rel => "stylesheet", :type => "text/css"}/
    / Syntax highlighting core file
    %script{:src => "slippy/src/highlighter/shCore.js", :type => "text/javascript"}
    / Syntax highlighting brushes, remove those you don't need
    %script{:src => "slippy/src/highlighter/shBrushBash.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushCpp.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushCSharp.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushCss.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushDelphi.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushDiff.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushGroovy.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushJava.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushJScript.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushPhp.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushPlain.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushPython.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushRuby.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushScala.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushSql.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushVb.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushXml.js", :type => "text/javascript"}
    / Syntax highlighting styles
    %link{:href => "slippy/src/highlighter/shCore.css", :rel => "stylesheet", :type => "text/css"}/
    %link{:href => "slippy/src/highlighter/shThemeDefault.css", :rel => "stylesheet", :type => "text/css"}/
    / Slippy init code
    :javascript
      $(function() {
          $(".slide").slippy({
              // settings go here
              // possible values are:
              //  - animLen, duration for default animations (0 = disabled)
              //  - animInForward, receives a slide and animates it
              //  - animInRewind, receives a slide and animates it
              //  - animOutForward, receives a slide and animates it
              //  - animOutRewind, receives a slide and animates it
              //  - baseWidth, defines the base for img resizing, if you don't want only
              //    full-width images, specify this as the pixel width of a slide so that
              //    images are scaled properly (default is 620px wide)
              //  - ratio, defines the width/height ratio of the slides, defaults to 1.3 (620x476)
              //  - margin, the fraction of screen to use as slide margin, defaults to 0.15
          });
          SyntaxHighlighter.all();
      });
    / Custom style for this deck
    :css
      .slide.nofooter {
        border: 0;
        background: 0;
      }
  %body


    .slide
      .vcenter
        %br
        %h2 OpenFlow Framework Trema
        %h2 Hands-on Tutorial
        %br
        %br
        %br
        %p
          Hideyuki Shimonishi
          %a{:href => "http://twitter.com/hide_shimonishi"} @hide_shimonishi
          %br
          Yasuhito Takamiya
          %a{:href => "http://twitter.com/yasuhito"} @yasuhito
          %br
          Kazushi Sugyo
          %br
          NEC
          %br
          %br
          %p CHANGE & OFELIA Summer School
          %p November 9, 2011


    .slide
      %h1 Agenda
      %ul
        %li Introduction and design condept
        %li Hands-on coding
        %li Summary


    .slide
      %h1 We are...
      %p Trema team from NEC laboratories
      %ul
        %li Hideyuki (Networking Ninja)
        %li Yasuhito (HPC and Middleware)
        %li Kazushi (KAME: IPv6 stack for *BSD)


    .slide
      %h1 Q: Why Framework?
      %p
        %b A: High productivity (e.g., Rails)
      %ul
        %li "common operations" can be written in short
        %li Full-stack: develop with your laptop
      %br
      %p â†’ Tight loops of "coding, testing, and debugging"
      %p
        %span{:style => "background-color: #ffff00"} ...And there were no such programming framework in OpenFlow yet.


    .slide
      %h1 Features of Trema Framework
      %p
        %span{:style => "background-color: #ffff00"} Most "modern" framework for OpenFlow
      %ul
        %li Ruby or C (Ruby's productivity + C's speed)
        %li Full-stack: develop with your laptop
        %li Open development process on github (GPL2)


    .slide
      %h1 Voices from Experts
      %p
        %i "I poked through Trema recently.  It looks like a *great* project. Very clean."
        %i (openflow-discuss list)
      .right
        %p Martin Casado (Nicira CTO)


    .slide
      %h1 Trema Design Concept
      .vcenter
        %h1 "Write it short, run it quickly"


    .slide
      %h1 Trema Design Concept
      .vcenter
        %h1
          "
          %span{:style => "background-color: #ffff00"}Write it short,
          run it quickly"


    .slide
      %h1 Why short code?
      %p If you can keep your code short,
      %ul
        %li more quickly you can finish your product,
        %li less incidence of software bugs,
        %li and easier to maintainance your code.

        
    .slide
      %h1 Example: Trema repeater-hub
      %pre{:class => "brush: ruby; highlight: [3, 8]"}
        :preserve
          class RepeaterHub < Controller
            def packet_in datapath_id, message
              send_flow_mod_add(
                datapath_id,
                :match => ExactMatch.from( message ),
                :actions => ActionOutput.new( OFPP_FLOOD )
              )
              send_packet_out(
                datapath_id,
                :packet_in => message,
                :actions => ActionOutput.new( OFPP_FLOOD )
              )
            end
          end
      %p
        Very concise, and there are only a few essential pieces (flow_mod + FLOOD) in this code.


    .slide
      %h1 Let's compare Trema with
      %ul
        %li NOX (Python binding)
        %li Beacon (Java)


    .slide
      %h1 NOX (Python binding)
      %p Redundant code!
      %pre{:class => "brush: python; highlight: [2, 8, 17]"}
        :preserve
          class pyswitch(Component):
              def __init__(self, ctxt):
                  global inst
                  Component.__init__(self, ctxt)
                  self.st = {}
                  inst = self

              def install(self):
                  inst.register_for_packet_in(packet_in_callback)
                  inst.register_for_datapath_leave(datapath_leave_callback)
                  inst.register_for_datapath_join(datapath_join_callback)
                  inst.post_callback(1, timer_callback)

              def getInterface(self):
                  return str(pyswitch)

              def getFactory():
                  class Factory:
                      def instance(self, ctxt):
                          return pyswitch(ctxt)
                  return Factory()


    .slide
      %h1 Beacon (Java)
      %p We don't use Java :-) (static typing system WITHOUT good type inference mechanism makes your code looong!)
      %div{:align => "center"}
        %img{:src => "./static-typing.gif", :height => "60%"}/


    .slide
      %h1 Trema Design Concept
      .vcenter
        %h1
          "Write it short,
          %span{:style => "background-color: #ffff00"} run it quickly
          "


    .slide
      %h1 Pains of OpenFlow development
      %p
        %i "I don't have a OpenFlow switch."

      %br

      %p
        %i "It is complicated to setup OpenFlow development environment (network configurations and VM installations etc.)"

      %br

      %p
        %i "There are no network environments here usable for OpenFlow experiments."

      .right
        %p Anonymous programmer


    .slide
      %h1 Trema Works with No Pain
      %p
        You can build a virtual network on your laptop and test your own controllers on it.
      %ul
        %li Run your controller without modifications
        %li Send and receive test packets between virtual hosts
        %li Dump packets and flow-tables etc.

      %br

      %p.right See how it works...
        

    .slide
      .vcenter
        %h1 Hands-on Coding Section
        %h1 Walk-Through of Development with Trema


    .slide
      %h1 Let's Setup Trema!
      %pre.brush:.plain
        :preserve
          $ git clone git://github.com/trema/trema.git
          $ ./trema/build.rb
      %p
        %span{:style => "background-color: #ffff00"} And there are no step three!


    .slide
      %h1 Coding #1: Your first controller
      %p
        Define a controller as a class and make it derived from
        %span{:style => "background-color: #ffff00"} Controller class
      %pre.brush:.ruby
        :preserve
          # simple.rb
          class SimpleController < Controller
          end
      %br

      %p
        Run it with
        %span{:style => "background-color: #ffff00"} trema run
        command:
      %pre.brush:.plain
        :preserve
          % ./trema run ./simple.rb


    .slide
      %h1 Coding #2: Hello Trema!

      %p
        Add a
        %span{:style => "background-color: #ffff00"} start method
        to the controller class.
      %pre{:class => "brush: ruby; highlight: [3,4,5]"}
        :preserve
          # hello.rb
          class HelloController < Controller
            def start
              puts "Hello, Trema!"
            end
          end
      %p It is a hook method invoked at startup (initializer).

      %br

      %p You can run it with trema run
      %pre{:class => "brush: ruby; highlight: [2]"}
        :preserve
          % ./trema run ./hello.rb
          Hello, Trema!


    .slide
      %h1 Class in Ruby
      %pre.brush:.ruby
        :preserve
          class ClassName < SuperClassName
            def method_name arg1, arg2
              # method body
            end
          end


    .slide
      %h1 Coding #3: Switch Monitor
      %p Switch monitor tracks all switches in a network
      %ul
        %li Updates the list of switches in real-time
        %li Notifies when a new switch is UP
        %li Notifies when a switch becomes DOWN


    .slide
      %h1 Coding #3: Switch Monitor
      %pre.brush:.ruby
        :preserve
          # src/examples/switch_monitor/switch-monitor.rb
          class SwitchMonitor < Controller
            periodic_timer_event :show_switches, 10

            def start
              @switches = []
            end

            def switch_ready datapath_id
              @switches << datapath_id.to_hex
              info "Switch \#{ datapath_id.to_hex } is UP"
            end

            def switch_disconnected datapath_id
              @switches -= [ datapath_id.to_hex ]
              info "Switch \#{ datapath_id.to_hex } is DOWN"
            end

            private

            def show_switches
              info "All switches = " + @switches.sort.join( ", " )
            end
          end


    .slide
      %h1 Event Handlers
      %pre{:class => "brush: ruby; highlight: [9,10,11,12,14,15,16,17]"}
        :preserve
          # src/examples/switch_monitor/switch-monitor.rb
          class SwitchMonitor < Controller
            periodic_timer_event :show_switches, 10

            def start
              @switches = []
            end

            def switch_ready datapath_id
              @switches << datapath_id.to_hex
              info "Switch \#{ datapath_id.to_hex } is UP"
            end

            def switch_disconnected datapath_id
              @switches -= [ datapath_id.to_hex ]
              info "Switch \#{ datapath_id.to_hex } is DOWN"
            end

            private

            def show_switches
              info "All switches = " + @switches.sort.join( ", " )
            end
          end


    .slide
      %h1 switch_ready handler
      %pre{:class => "brush: ruby; highlight: [8,9,10,11]"}
        :preserve
          class SwitchMonitor < Controller
            periodic_timer_event :show_switches, 10

            def start
              @switches = []
            end

            def switch_ready datapath_id
              @switches << datapath_id.to_hex
              info "Switch \#{ datapath_id.to_hex } is UP"
            end
      %ul
        %li When a switch is connected to the controller, add (<<) its dpid to the switch-list instance variable (@switches)
        %li Then output like "Switch 0xabc is UP"


    .slide
      %h1 List in Ruby
      %pre.brush:.ruby
        :preserve
          % irb
          > zoo = []
          => []

          > zoo << "bat"
          => ["bat"]

          > zoo << "gnu"
          => ["bat", "gnu"]

          > zoo << "dog"
          => ["bat", "gnu", "dog"]

          > zoo -= ["bat"]
          => ["gnu", "dog"]

          > zoo.sort
          => ["dog", "gnu"]
      %p irb = interactive ruby (REPL)


    .slide
      %h1 switch_disconnected handler
      %ul
        %li
          When a switch becomes DOWN, remove (-=) its dpid from @switches list
        %li Then output like "Switch 0xabc is DOWN"
      %pre{:class => "brush: ruby; highlight: [6,7,8,9]"}
        :preserve
          # src/examples/switch_monitor/switch-monitor.rb
          class SwitchMonitor < Controller

              ...

            def switch_disconnected datapath_id
              @switches -= [ datapath_id.to_hex ]
              info "Switch \#{ datapath_id.to_hex } is DOWN"
            end

              ...



    .slide
      %h1 show_switches timer handler
      %ul
        %li Output the switch list like "All switches = 0xabc, 0xdef, ..." in every 10 seconds
        %li periodic_timer_handler registers show_switches method as a timer handler
      %pre{:class => "brush: ruby; highlight: [2,6,7,8]"} 
        :preserve
          class SwitchMonitor < Controller
            periodic_timer_event :show_switches, 10

              ...

            def show_switches
              info "All switches = " + @switches.sort.join( ", " )
            end
          end


    .slide
      %h1 Run Switch Monitor

      %p Write a virtual network configuration (DSL) that adds three switches to the network.
      %pre.brush:.ruby
        :preserve
          # src/examples/switch_monitor/switch-monitor.conf
          vswitch { datapath_id 0x1 }
          vswitch { datapath_id 0x2 }
          vswitch { datapath_id 0x3 }

      %p
        Then pass it to trema run with
        %span{:style => "background-color: #ffff00"} -c
        option
      %pre.brush:.plain
        :preserve
          % ./trema run ./src/examples/switch_monitor/switch-monitor.rb -c ./src/examples/switch_monitor/switch-monitor.conf
          Switch 0x3 is UP
          Switch 0x2 is UP
          Switch 0x1 is UP
          All switches = 0x1, 0x2, 0x3
          All switches = 0x1, 0x2, 0x3
          All switches = 0x1, 0x2, 0x3
            ...


    .slide
      %h1 Virtual Network DSL
      %ul
        %li You can build arbitrally network topology on your laptop and run your controlller on it.
        %li Debug your controller by sending and receiving test packets between virtual hosts.
        %li You can use virtual switch, host, and link to construct the virtual network.


    .slide
      %h1 Shutdown a Switch
      %p Let's test switch_disconnected handler by causing a fault in the virtual network

      %br

      %p
        Open another terminal and run
        %span{:style => "background-color: #ffff00"} trema kill
      %pre.brush:.bash
        :preserve
          % ./trema kill 0x3

      %br

      %p Then you can see "Switch 0x??? is DOWN"
      %pre{:class => "brush: ruby; highlight: [9]"} 
        :preserve
          % ./trema run ./switch-monitor.rb -c ./switch-monitor.conf
          Switch 0x3 is UP
          Switch 0x2 is UP
          Switch 0x1 is UP
          All switches = 0x1, 0x2, 0x3
          All switches = 0x1, 0x2, 0x3
          All switches = 0x1, 0x2, 0x3
            ...
          Switch 0x3 is DOWN


    .slide
      %h1 Summary: Switch Monitor
      %ul
        %li Implement the logic of a controller by adding event handlers (e.g., switch_ready and switch_disconnected)
        %li Network DSL makes it possible to test your own controller even if you don't have OpenFlow switches.


    .slide
      %h1 Coding #4: packet-in handling
      %p Add the following method to handle packet-in
      %pre{:class => "brush: ruby; highlight: [2,3,4]"}
        :preserve
          class SimpleController < Controller
            def packet_in dpid, message
              puts "New packet_in message!"
            end
              ...
      %ul
        %li dpid: the datapath ID of the switch that received a packet-in
        %li message: packet-in message object


    .slide
      %h1 Let's Send Packets!
      %p Firstly, you must add virtual hosts to send/receive packets and connect them to a virtual switch:
      %pre.brush:.ruby
        :preserve
          vswitch { dpid 0xabc }

          # Add two virtual hosts
          vhost("host1") {
            mac "00:00:00:00:00:01"
          }
          vhost("host2") {
            mac "00:00:00:00:00:02"
          }

          # connect hosts to a switch
          link "0xabc", "host1"
          link "0xabc", "host2"


    .slide
      %h1 Let's Send Packets!
      %ul
        %li Send test packets with send_packets
        %li The following will send ten packets from host1 to host2 in a second
      %pre.brush:.plain
        :preserve
          % ./trema send_packets --source host1 --dest host2 --n_pkts 10 --pps 10
          New packet_in message!
          New packet_in message!
          New packet_in message!
          New packet_in message!
          New packet_in message!
            ...


    .slide
      %h1 Large and complex topology?
      %p Ten switches full-mesh topology configurations in flat (about 80 LOC)
      %pre.brush:.ruby
        :preserve
          vswitch { dpid "0x1" }
          vswitch { dpid "0x2" }
          vswitch { dpid "0x3" }
          vswitch { dpid "0x4" }
            ...

          link "0x1", "0x2"
          link "0x1", "0x3"
          link "0x1", "0x4"
          link "0x1", "0x5"
          link "0x1", "0x6"
          link "0x1", "0x7"
          link "0x1", "0x8"
          link "0x1", "0x9"
          link "0x1", "0x10"
          link "0x2", "0x3"
          link "0x2", "0x4"
            ...


    .slide
      %h1 Advanced DSL Usage
      %ul
        %li You can use full Ruby syntax in the DSL
        %li the full-mesh topology can be rewritten briefly with nested loops:
      %pre.brush:.ruby
        :preserve
          $nswitch = 10

          1.upto( $nswitch ).each do | sw1 |
            vswitch { dpid sw1.to_hex }

            1.upto( $nswitch ).each do | sw2 |
              link sw1.to_hex, sw2.to_hex if sw1 < sw2
            end
          end
      %p Very concise!


    .slide
      %h1 Coding #5: Modifying flow-table
      %p Write a flow-entry that forwards incoming packets to the next switch port
      %pre{:class => "brush: ruby; highlight: [3,4,5,6,7,8]"}
        :preserve
          class SimpleController < Controller
            def packet_in dpid, message
              send_flow_mod_add(
                dpid,
                :match => ExactMatch.from( message ),
                :buffer_id => message.buffer_id,
                :actions => ActionOutput.new( message.in_port + 1 )
              )
            end
          end
      %p Very concise!


    .slide
      %h1 Comparison of flow_mod API

      %p Trema
      %pre.brush:.ruby
        :preserve
          send_flow_mod_add(
            dpid,
            :match => ExactMatch.from( message ),
            :buffer_id => message.buffer_id,
            :actions => ActionOutput.new( message.in_port + 1 )
          )

      %p NOX
      %pre.brush:.python
        :preserve
          inst.install_datapath_flow(
            dpid,
            extract_flow(packet),
            CACHE_TIMEOUT, 
            openflow.OFP_FLOW_PERMANENT,
            [[openflow.OFPAT_OUTPUT, [0, prt[0]]]],
            bufid,
            openflow.OFP_DEFAULT_PRIORITY,
            inport,
            buf
          )


    .slide
      %h1 Creating a Match Structure

      %p You can easily create an exact match from incoming packet_in message:

      %pre{:class => "brush: ruby; highlight: [3]"}
        :preserve
          send_flow_mod_add(
            dpid,
            :match => ExactMatch.from( message ),
            :buffer_id => message.buffer_id,
            :actions => ActionOutput.new( message.in_port + 1 )
          )

      %p This is equivalent with:

      %pre.brush:.ruby
        :preserve
          :match => Match.new(
            :in_port = message.in_port,
            :nw_src => message.nw_src,
            :nw_dst => message.nw_dst,
            :tp_src => message.tp_src,
            :tp_dst => message.tp_dst,
            :dl_src => message.dl_src,
              ...
          )


    .slide
      %h1 Summary: Trema API
      %ul
        %li There are many shortcuts and syntactic sugars in Trema API that can simplify and shorten your code
        %li
          More details can be found in Ruby API Document 
          %a{:href => "http://rubydoc.info/github/trema/trema/"} http://rubydoc.info/github/trema/trema/


    .slide
      .vcenter
        %h2 Short Break (15min)


    .slide
      %h1 Traffic Monitor
      %ul
        %li L2 switch
        %li Counts the number of packets sent by each user
        %li Each user is identified by its MAC address


    .slide
      %h1 Traffic Monitor classes
      %ul
        %li
          %span{:style => "background-color: #ffff00"} FDB class
          learns {MAC, switch-port} pair
        %li
          %span{:style => "background-color: #ffff00"} Counter class
          keeps number of packets sent by each user
        %li
          %span{:style => "background-color: #ffff00"} TrafficMonitor class
          acts as a Controller
      %br
      %p Let's implement them one by one


    .slide
      %h1 Coding #6: FDB Class
      %pre.brush:.ruby
        :preserve
          # src/examples/traffic_monitor/fdb.rb
          class FDB
            def initialize
              @db = {}
            end

            def lookup mac
              @db[ mac ]
            end

            def learn mac, port_number
              @db[ mac ] = port_number
            end
          end


    .slide
      %h1 FDB Class
      %pre.brush:.ruby
        :preserve
          % irb
          > require "fdb"
          > fdb = FDB.new

          > fdb.lookup "00:00:00:00:00:01"
          => nil

          > fdb.learn "00:00:00:00:00:01", 1
          > fdb.lookup "00:00:00:00:00:01"
          => 1

          > fdb.learn "00:00:00:00:00:02", 2
          > fdb.lookup "00:00:00:00:00:02"
          => 2


    .slide
      %h1 Hash in Ruby
      %pre.brush:.ruby
        :preserve
          % irb
          > price = { "Mac" => 1000, "iPhone" => 500, "iPad" => 600 }
          => { "Mac" => 1000, "iPhone" => 500, "iPad" => 600 }

          > price[ "iPhone" ]
          => 500

          > price[ "iPad" ]
          => 600

          > price[ "iPod Touch" ]
          => nil

          > price[ "iPod Touch" ] = 300
          => 300

          > price[ "iPod Touch" ]
          => 300


    .slide
      %h1 Coding #7: Counter Class
      %pre.brush:.ruby
        :preserve
          # src/examples/traffic_monitor/counter.rb
          class Counter
            def initialize
              @db = {}
            end

            def add mac, packet_count, byte_count
              @db[ mac ] ||= { :packet_count => 0, :byte_count => 0 }
              @db[ mac ][ :packet_count ] += packet_count
              @db[ mac ][ :byte_count ] += byte_count
            end

            def each_pair &block
              @db.each_pair &block
            end
          end


    .slide
      %h1 Counter Class
      %pre.brush:.ruby
        :preserve
          % irb
          > require "counter"
          > counter = Counter.new

          > counter.add "00:00:00:00:00:01", 1, 100
          > counter.add "00:00:00:00:00:02", 1, 100
          > counter.add "00:00:00:00:00:02", 1, 100

          > counter.each_pair do | mac, counter |
          >   p mac, counter
          > end
          "00:00:00:00:00:01"
          {:packet_count=>1, :byte_count=>100}
          "00:00:00:00:00:02"
          {:packet_count=>2, :byte_count=>200}


    .slide
      %h1 TrafficMonitor Class Overview
      %p TrafficMonitor has the following two handlers
      %ul
        %li packet_in: L2 switching. When a packet_in comes, learns its {MAC, switch-port} pair and sends flow_mod
        %li flow_removed: Counts the packets from each user. This traffic information is piggy-backed with flow_removed messages


    .slide
      %h1 Coding #8: TrafficMonitor#packet_in
      %pre{:class => "brush: ruby; highlight: [16,17,19]"}
        :preserve
          class TrafficMonitor < Controller
            periodic_timer_event :show_counter, 10

            def start
              @counter = Counter.new
              @fdb = FDB.new
            end

            def packet_in datapath_id, message
              macsa = message.macsa
              macda = message.macda

              @fdb.learn macsa, message.in_port
              @counter.add macsa, 1, message.total_len
              out_port = @fdb.lookup( macda )
              if out_port
                flow_mod datapath_id, macsa, macda, out_port
                packet_out datapath_id, message, out_port
              else
                flood datapath_id, message
              end
            end


    .slide
      %h1 Coding #9: TrafficMonitor#flow_mod
      %pre{:class => "brush: ruby; highlight: [6]"}
        :preserve
            private
              ...
            def flow_mod datapath_id, macsa, macda, out_port
              send_flow_mod_add(
                datapath_id,
                :hard_timeout => 10,
                :match => Match.new(
                  :dl_src => macsa.to_s,
                  :dl_dst => macda.to_s
                ),
                :actions => Trema::ActionOutput.new( out_port )
              )
            end
      %p hard_timeout forces flow-entries to be removed in ten seconds and therefore causes flow_removed


    .slide
      %h1 Coding #10: TrafficMonitor#packet_out and flood
      %pre{:class => "brush: ruby; highlight: [9]"}
        :preserve

          class TrafficMonitor < Controller
              ...
            private
              ...
            def packet_out datapath_id, message, out_port
              send_packet_out(
                datapath_id,
                :packet_in => message,
                :actions => Trema::ActionOutput.new( out_port )
              )
            end

            def flood datapath_id, message
              packet_out datapath_id, message, OFPP_FLOOD
            end
          end


    .slide
      %h1 Coding #11: TrafficMonitor#flow_removed
      %pre.brush:.ruby
        :preserve
          class TrafficMonitor < Controller
            ...

          def flow_removed datapath_id, message
            @counter.add(
              message.match.dl_src,
              message.packet_count,
              message.byte_count
            )
          end


    .slide
      %h1 Run Traffic Monitor
      %p DSL
      %pre.brush:.ruby
        :preserve
          vswitch { dpid 0xabc }

          # Add two virtual hosts
          vhost("host1") {
            mac "00:00:00:00:00:01"
          }
          vhost("host2") {
            mac "00:00:00:00:00:02"
          }

          # connect hosts to a switch
          link "0xabc", "host1"
          link "0xabc", "host2"

      %p Run
      %pre.brush:.ruby
        :preserve
          % ./trema run ./traffic-monitor.rb -c ./traffic-monitor.conf


    .slide
      %h1 Let's Send Packets!
      %p Open a new terminal and send packets betweeen host1 and host2:
      %pre.brush:.bash
        :preserve
          % ./trema send_packets --source host1 --dest host2 --n_pkts 10 --pps 10
          % ./trema send_packets --source host2 --dest host1 --n_pkts 10 --pps 10
      %p Then the output will look like:
      %pre.brush:.bash
        :preserve
            ...
          00:00:00:00:00:01 10 packets (640 bytes)
          00:00:00:00:00:02 10 packets (640 bytes)
            ...


    .slide
      .vcenter
        %h1 Wrap-up


    .slide
      %h1 Trema Sample Apps
      %ul
        %li Trema distribution includes various samples (in Ruby and C)
        %li We recommend to run them and read its source code
      %pre.brush:.plain
        :preserve
          % ls src/examples
          cbench_switch          dumper            hash_bench
          hello_trema            learning_switch   list_switches
          multi_learning_switch  openflow_message  packet_in
          repeater_hub           switch_info       switch_monitor
          traffic_monitor


    .slide
      %h1 trema/apps
      %p
        %a{:href => "https://github.com/trema/apps"}https://github.com/trema/apps
      %p "Nearly production-level" apps written in Trema
      %ul
        %li routing switch
        %li load balancer
        %li topology manager etc. etc...


    .slide
      %div{:align => "center"}
        %img{:src => "./TremaApps.gif", :height => "90%"}/


    .slide
      %h1 Performance: cbench benchmarks
      %p cbench = A controller benchmark that measures flow-setup/sec
      %pre.brush:.plain
        :preserve
          1   switches: fmods/sec:  10627   total = 10.626989 per ms 
          1   switches: fmods/sec:  8184   total = 8.183992 per ms 
          1   switches: fmods/sec:  7542   total = 7.541992 per ms 
          1   switches: fmods/sec:  7852   total = 7.851992 per ms 
          1   switches: fmods/sec:  8243   total = 8.242992 per ms 
          1   switches: fmods/sec:  7807   total = 7.806977 per ms 
          1   switches: fmods/sec:  8484   total = 8.483992 per ms 
          1   switches: fmods/sec:  8401   total = 8.400992 per ms 
          1   switches: fmods/sec:  8129   total = 8.128992 per ms 
          1   switches: fmods/sec:  7853   total = 7.852788 per ms 
          RESULT: 1 switches 9 tests min/max/avg/stdev = 7541.99/8483.99/8054.97/292.12 responses/s
      %p About 8,000 flow-setup/sec


    .slide
      %h1 cbench with C version controller
      %p About 14,000 flow-setup/sec
      %pre.brush:.plain
        :preserve
          1   switches: fmods/sec:  8891   total = 8.890991 per ms 
          1   switches: fmods/sec:  14864   total = 14.863985 per ms 
          1   switches: fmods/sec:  14316   total = 14.315986 per ms 
          1   switches: fmods/sec:  14548   total = 14.547985 per ms 
          1   switches: fmods/sec:  14648   total = 14.647956 per ms 
          1   switches: fmods/sec:  13318   total = 13.317987 per ms 
          1   switches: fmods/sec:  14376   total = 14.375986 per ms 
          1   switches: fmods/sec:  13143   total = 13.142987 per ms 
          1   switches: fmods/sec:  14275   total = 14.274986 per ms 
          1   switches: fmods/sec:  14280   total = 14.279986 per ms 
          RESULT: 1 switches 9 tests min/max/avg/stdev = 13142.99/14863.99/14196.43/549.16 responses/s
      %p We recommend to write a controller in Ruby at first, then rewrite them with C if need be


    .slide
      %h1 Unit-Test
      %ul
        %li You can write unit-tests of sending/receiving packets between hosts and flow-table entries of switches etc. with RSpec
        %li
          The details can be found in 
          %span{:style => "background-color: #ffff00"} spec/
          directory


    .slide
      %h1 Unit-Test Example
      %pre.brush:.ruby
        :preserve
          describe RepeaterHub do
            around do | example |
              network {
                vswitch("switch") { datapath_id "0xabc" }
                vhost("host1") { promisc "on" }
                vhost("host2") { promisc "on" }
                link "switch", "host1"
                link "switch", "host2"
              }.run( RepeaterHub ) {
                example.run
              }
            end

            context "when host1 sends one packet to host2" do
              describe "switch" do
                before { send_packets "host1", "host2" }
                subject { switch( "switch" ) }
                it { should have( 1 ).flows }
                its( "flows.first.actions" ) { should == "FLOOD" }
              end

                ...


    .slide
      %h1 Summary
      %p
        %span{:style => "background-color: #ffff00"} OpenFlow framework Trema
      %ul
        %li You can write controllers short and run it quickly
        %li Many examples in src/examples and trema/apps repository
        %li Pull-requests and bug-reports are welcome!


    .slide
      %h1 Meta
      %ul
        %li
          Trema HomePage
          %a{:href => "http://trema.github.com/trema/"} http://trema.github.com/trema/
        %li
          Ruby API Document:
          %a{:href => "http://rubydoc.info/github/trema/trema/"} http://rubydoc.info/github/trema/trema/
        %li
          Twitter Account:
          %a{:href => "http://twitter.com/trema_news"} @trema_news


    .layout{"data-name" => "default"}
      %content
      .footer
        %span.left
          %b Hideyuki Shimonishi, Yasuhito Takamiya, Kazushi Sugyo
        %span.right
          Trema on
          %a{:href => "http://github.com/trema/trema/"} github
        %span.left CHANGE & OFELIA Summer School 2011
        %span.right
          Twitter
          %a{:href => "http://twitter.com/trema_news"} @trema_news


    .layout.nofooter{"data-name" => "alt"}
      %content
