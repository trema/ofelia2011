!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-equiv" => "Content-Type"}/
    / Slide meta data, remove/edit as you see fit
    %title OpenFlow platform Trema, hands-on session
    %meta{:content => "Yasuhito Takamiya", :name => "author"}/
    %meta{:content => "yasuhito@gmail.com", :name => "email"}/
    %meta{:content => "November 9, 2011", :name => "date"}/
    / Slippy core file and dependencies
    %script{:src => "slippy/src/jquery.min.js", :type => "text/javascript"}
    %script{:src => "slippy/src/jquery.history.js", :type => "text/javascript"}
    %script{:src => "slippy/src/slippy.js", :type => "text/javascript"}
    / Slippy structural styles
    %link{:href => "slippy/src/slippy.css", :rel => "stylesheet", :type => "text/css"}/
    / Trema theme
    %link{:href => "trema.css", :rel => "stylesheet", :type => "text/css"}/
    / Syntax highlighting core file
    %script{:src => "slippy/src/highlighter/shCore.js", :type => "text/javascript"}
    / Syntax highlighting brushes, remove those you don't need
    %script{:src => "slippy/src/highlighter/shBrushBash.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushCpp.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushCSharp.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushCss.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushDelphi.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushDiff.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushGroovy.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushJava.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushJScript.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushPhp.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushPlain.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushPython.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushRuby.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushScala.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushSql.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushVb.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushXml.js", :type => "text/javascript"}
    / Syntax highlighting styles
    %link{:href => "slippy/src/highlighter/shCore.css", :rel => "stylesheet", :type => "text/css"}/
    %link{:href => "slippy/src/highlighter/shThemeDefault.css", :rel => "stylesheet", :type => "text/css"}/
    / Slippy init code
    :javascript
      $(function() {
          $(".slide").slippy({
              // settings go here
              // possible values are:
              //  - animLen, duration for default animations (0 = disabled)
              //  - animInForward, receives a slide and animates it
              //  - animInRewind, receives a slide and animates it
              //  - animOutForward, receives a slide and animates it
              //  - animOutRewind, receives a slide and animates it
              //  - baseWidth, defines the base for img resizing, if you don't want only
              //    full-width images, specify this as the pixel width of a slide so that
              //    images are scaled properly (default is 620px wide)
              //  - ratio, defines the width/height ratio of the slides, defaults to 1.3 (620x476)
              //  - margin, the fraction of screen to use as slide margin, defaults to 0.15
          });
          SyntaxHighlighter.all();
      });
    / Custom style for this deck
    :css
      .slide.nofooter {
        border: 0;
        background: 0;
      }
  %body


    .slide
      .vcenter
        %h2 OpenFlow platform Trema
        %h2 Hands-on session
        %br
        %br
        %br
        %p
          Hideyuki Shimonishi
          %a{:href => "http://twitter.com/hide_shimonishi"} @hide_shimonishi
          %br
          Yasuhito Takamiya
          %a{:href => "http://twitter.com/yasuhito"} @yasuhito
          %br
          Kazushi Sugyo
          %br
          NEC
          %br
          %br
          %p CHANGE & OFELIA Summer School
          %p November 9, 2011


    .slide
      %h1 We are...
      %p Trema team from NEC laboratories
      %ul
        %li Hideyuki (Networking Ninja)
        %li Yasuhito (HPC and Middleware)
        %li Kazushi (KAME: IPv6 stack for *BSD)


    .slide
      %h1 Q: Why Framework?
      %p
        %b A: High productivity (e.g., Rails, Sinatra)
      %ul
        %li "common operations" can be written shortly
        %li Full-stack: develop with your laptop
        %li Tight loops of "coding, testing, and debugging"
      %br
      %p
        %span{:style => "background-color: #ffff00"} ...And there were no such programming framework in OpenFlow yet.


    .slide
      %h1 Features of Trema Framework
      %p
        %span{:style => "background-color: #ffff00"} Most "modern" framework for OpenFlow
      %ul
        %li Ruby or C (Ruby's productivity + C's speed)
        %li Full-stack: develop with your laptop
        %li Open development process on github (GPL2)


    .slide
      %h1 Voices from Exparts
      %p
        %i "I poked through Trema recently.  It looks like a *great* project. Very clean."
        %i (openflow-discuss list)
      .right
        %p Martin Casado (Nicira CTO)


    .slide
      %h1 Trema Design Concept
      .vcenter
        %h1 "Write shortly, run it quickly"


    .slide
      %h1 Trema Design Concept
      .vcenter
        %h1
          "
          %span{:style => "background-color: #ffff00"}Write shortly,
          run it quickly"


    .slide
      %h1 Why want to write shortly?
      %p If you can write your code more shortly,
      %ul
        %li more quickly you can finish coding,
        %li less incidence of software bug,
        %li and easier to maintainance your code.

        
    .slide
      %h1 Example: Trema repeater-hub
      %pre{:class => "brush: ruby; highlight: [3, 8]"}
        :preserve
          class RepeaterHub < Controller
            def packet_in datapath_id, message
              send_flow_mod_add(
                datapath_id,
                :match => ExactMatch.from( message ),
                :actions => ActionOutput.new( OFPP_FLOOD )
              )
              send_packet_out(
                datapath_id,
                :packet_in => message,
                :actions => ActionOutput.new( OFPP_FLOOD )
              )
            end
          end
      %p
        Only need essential method invocations in this code.
        %br
        (flow_mod then FLOOD)


    .slide
      %h1 Let's compare Trema with
      %ul
        %li NOX (Python binding)
        %li Beacon (Java)


    .slide
      %h1 NOX (Python binding)
      %p Redundunt code!
      %pre{:class => "brush: python; highlight: [2, 8, 17]"}
        :preserve
          class pyswitch(Component):
              def __init__(self, ctxt):
                  global inst
                  Component.__init__(self, ctxt)
                  self.st = {}
                  inst = self

              def install(self):
                  inst.register_for_packet_in(packet_in_callback)
                  inst.register_for_datapath_leave(datapath_leave_callback)
                  inst.register_for_datapath_join(datapath_join_callback)
                  inst.post_callback(1, timer_callback)

              def getInterface(self):
                  return str(pyswitch)

              def getFactory():
                  class Factory:
                      def instance(self, ctxt):
                          return pyswitch(ctxt)
                  return Factory()


    .slide
      %h1 Beacon (Java)
      %p We dislike Java (static typing system WITHOUT good type inference mechanism makes your code looong!)
      %div{:align => "center"}
        %img{:src => "./static-typing.gif", :height => "60%"}/


    .slide
      %h1 Trema Design Concept
      .vcenter
        %h1
          "Write shortly,
          %span{:style => "background-color: #ffff00"} run it quickly
          "


    .slide
      %h1 Pain of OpenFlow development
      %p
        %i "It is complicated to setup OpenFlow development environment"
        %i (network configurations and VM installations etc.)

      %br

      %p
        %i "I don't have a OpenFlow switch."

      %br

      %p
        %i "In the first place, I don't have a network usable for OpenFlow experiments."

      .right
        %p anonymous programmer


    .slide
      %h1 Trema Works with No Pain
      %p
        You can build a virtual network on your laptop and test your own controllers on it.
      %ul
        %li Run your controller without modifications
        %li Send and receive test packets between virtual hosts
        %li Dump switch flow-tables etc.

      %br

      %p.right See how it works...
        

    .slide
      .vcenter
        %h1 Common work flow of development with Trema


    .slide
      %h1 Let's setup Trema!
      %pre.brush:.plain
        :preserve
          $ git clone git://github.com/trema/trema.git
          $ ./trema/build.rb
      %p And there are no step three!


    .slide
      %h1 Write your first controller
      %p Define a controller as a class and make it derived from Controller class
      %pre.brush:.ruby
        :preserve
          # simple-controller.rb

          class SimpleController < Controller
          end
      %br

      %p Run it with "trema run" command:
      %pre.brush:.plain
        :preserve
          % ./trema run ./simple-controller.rb


    .slide
      %h1 Coding Challenge #1: Hello Trema!
      %ul
        %li Trema の最初のプログラム
        %li 画面に Hello Trema! と表示するだけ


    .slide
      %h1 It's Shakyo Time!

      %span.right
        %img{:src => "./shakyo.jpg", :height => "20%"}/

      %ul
        %li
          Open a file with your favorite editor and let's
          %b shyakyo
          the following code.
        %li Shyakyo = The Japanese form of sutra transcription
        %li Just type it as is ... don't think at first, be calm like a Zen monk.

      %span.right
        %small The image was taken from http://bit.ly/tI6OXP


    .slide
      %h1 Syakyo: Hello Trema!
      %pre{:class => "brush: ruby; highlight: [3]"}
        :preserve
          # hello.rb
          class HelloController < Controller
            def start
              puts "Hello, Trema!"
            end
          end
      %p The start method is a start hook invoked at startup.


    .slide
      %h1 How to run
      %p You can execute *.rb with the following command:
      %pre.brush:.bash
        :preserve
          % ./trema run ./hello.rb
          Hello, Trema!


    .slide
      %h1 Ruby in one minute
      %h2 Class definition
      %pre.brush:.ruby
        :preserve
          class ClassName < SuperClassName
            def method_name arg1, arg2
              # method body
            end
          end


    .slide
      %h1 Coding Challenge #2: Switch Monitor
      %ul
        %li スイッチ一覧をリアルタイムに更新
        %li スイッチが起動したらメッセージを表示
        %li スイッチが切断したらメッセージを表示


    .slide
      %h1 問題: Switch Monitor
      %p 次の 3 箇所の下線部を埋めよ
      %pre.brush:.ruby
        :preserve
          class SwitchMonitor < Controller
            # 10 秒ごとに指定したメソッドを実行
            periodic_timer_event :______________, 10

            # スイッチが接続したときのハンドラ (引数 = スイッチの dpid)
            def ____________ datapath_id
              # ...
            end

            # スイッチが切断したときのハンドラ (引数 = スイッチの dpid)
            def ___________________ datapath_id
              # ...
            end

            private

            # スイッチの一覧を表示
            def show_switches
              # ...
            end
          end


    .slide
      %h1 Shyakyo: Variable and String in Ruby
      %ul
        %li irb = interactive ruby (REPL)
        %li "irb(main):001:0>" is a irb prompt so you need not type it
      %pre.brush:.ruby
        :preserve
          % irb
          irb(main):001:0> name = "Spider-Man"
          => "Spider-Man"

          irb(main):002:0> puts "My name is \#{ name }"
          My name is Spider-Man
          => nil


    .slide
      %h1 Shyakyo: List in Ruby
      %pre.brush:.ruby
        :preserve
          % irb
          irb(main):001:0> zoo = []
          => []

          irb(main):002:0> zoo << "bat"
          => ["bat"]

          irb(main):003:0> zoo << "gnu"
          => ["bat", "gnu"]

          irb(main):004:0> zoo << "dog"
          => ["bat", "gnu", "dog"]

          irb(main):005:0> zoo -= ["bat"]
          => ["gnu", "dog"]

          irb(main):006:0> zoo.sort
          => ["dog", "gnu"]


    .slide
      %h1 switch_ready ハンドラの実装
      %ul
        %li スイッチが接続すると、dpid の 16 進数表記を @switches に追加する
        %li "Switch 0xabc is UP" のように表示
        %li ヒント: number.to_hex で number を 16 進数表記に変換


    .slide
      %h1 問題
      %pre{:class => "brush: ruby; highlight: [9,10,11,12,13]"}
        :preserve
          class SwitchMonitor < Controller
            periodic_timer_event :show_switches, 10

            # 起動時にスイッチのリストを初期化
            def start
              @switches = []
            end

            # スイッチが接続したときのハンドラ (引数 = スイッチの dpid)
            def switch_ready datapath_id
              @switches << __________________
              puts "_____________________________________"
            end

              ...


    .slide
      %h1 switch_disconnected ハンドラの実装
      %ul
        %li スイッチが切断すると、dpid の 16 進数表記を @switches からはずす
        %li "Switch 0xabc is DOWN" のように表示
      %pre{:class => "brush: ruby; highlight: [6,7,8,9,10]"}
        :preserve
          class SwitchMonitor < Controller
            periodic_timer_event :show_switches, 10

              ...

            # スイッチが切断したときのハンドラ (引数 = スイッチの dpid)
            def switch_disconnected datapath_id
              @switches -= ______________________
              puts "_______________________________________"
            end

              ...


    .slide
      %h1 show_switches メソッドの実装
      %ul
        %li スイッチの一覧を "All switches = 0xabc, 0xdef, ..." のように表示
      %pre.brush:.ruby
        :preserve
          class SwitchMonitor < Controller
            periodic_timer_event :show_switches, 10

              ...


            private

            def show_switches
              puts "All switches = " + @switches._________________
            end
          end


    .slide
      %h1 解答: Switch Monitor
      %pre.brush:.ruby
        :preserve
          class SwitchMonitor < Controller
            periodic_timer_event :show_switches, 10

            def start
              @switches = []
            end

            def switch_ready datapath_id
              @switches << datapath_id.to_hex
              puts "Switch \#{ datapath_id.to_hex } is UP"
            end

            def switch_disconnected datapath_id
              @switches -= [ datapath_id.to_hex ]
              puts "Switch \#{ datapath_id.to_hex } is DOWN"
            end

            private

            def show_switches
              puts "All switches = " + @switches.sort.join( ", " )
            end
          end


    .slide
      %h1 Switch Monitor の起動

      %pre.brush:.plain
        :preserve
          % ./trema run ./switch-monitor.rb -c ./switch-monitor.conf
          Switch 0x3 is UP
          Switch 0x2 is UP
          Switch 0x1 is UP
          All switches = 0x1, 0x2, 0x3
          All switches = 0x1, 0x2, 0x3
          All switches = 0x1, 0x2, 0x3
            ...


    .slide
      %h1 スイッチをわざと落とす

      %p 別ターミナルで trema kill を実行
      %pre.brush:.bash
        :preserve
          % ./trema kill 0x3

      %p すると trema run を実行したターミナルで "Switch 0x??? is DOWN" が表示される
      %pre.brush:.plain
        :preserve
          % ./trema run ./switch-monitor.rb -c ./switch-monitor.conf
          Switch 0x3 is UP
          Switch 0x2 is UP
          Switch 0x1 is UP
          All switches = 0x1, 0x2, 0x3
          All switches = 0x1, 0x2, 0x3
          All switches = 0x1, 0x2, 0x3
            ...

          Switch 0x3 is DOWN


    .slide
      %h1 まとめ: Switch Monitor
      %ul
        %li イベントハンドラを書くことでコントローラのロジックを記述 (ex. switch_ready, switch_disconnected etc.)
        %li ネットワーク DSL を使えば OpenFlow スイッチを持っていなくても動作テストができる。


    .slide
      %h1 パケットを送ってみよう!
      %ul
        %li 仮想ホストを 2 台追加 (vhost)
        %li それぞれスイッチにつなぐ (link)
      %pre{:class => "brush: ruby; highlight: [5, 9, 14, 15]"}
        :preserve
          # 仮想スイッチ
          vswitch { dpid 0xabc }

          # 仮想ホストその 1
          vhost("host1") {
            mac "00:00:00:00:00:01"
          }
          # 仮想ホストその 2
          vhost("host2") {
            mac "00:00:00:00:00:02"
          }

          # スイッチとホストをつなげる
          link "0xabc", "host1"
          link "0xabc", "host2"


    .slide
      %h1 写経: パケットを送ってみよう!
      %p pakcet_in に反応するハンドラを追加
      %pre{:class => "brush: ruby; highlight: [7]"}
        :preserve
          class SimpleController < Controller
            #
            # packet_in のハンドラ
            #   dpid: パケットを受け取ったスイッチの dpid
            #   message: packet_in メッセージ本体
            #
            def packet_in dpid, message
              puts "New packet_in message!"
            end

              ...
          end


    .slide
      %h1 パケットを送ってみよう!
      %ul
        %li send_packets でテストパケットを送信
        %li host1 → host2 にパケットを 10 個送信
      %pre.brush:.plain
        :preserve
          % ./trema send_packets --source host1 --dest host2 --n_pkts 10 --pps 10
          New packet_in message!
          New packet_in message!
          New packet_in message!
          New packet_in message!
          New packet_in message!
          New packet_in message!
          New packet_in message!
          New packet_in message!
          New packet_in message!
          New packet_in message!
      %p → packet_in ハンドラが 10 回呼ばれる


    .slide
      %h1 仮想ネットワーク DSL
      %ul
        %li 開発マシン上に好きなトポロジを構築してコントローラを実行できる
        %li テストパケットを送受信してコントローラをデバッグできる
        %li 使える部品は仮想スイッチ、仮想ホスト、仮想リンク


    .slide
      %h1 大規模で複雑なトポロジ
      %p スイッチ 10 台のフルメッシュ接続をベタに書いた例 (約 80 行)
      %pre.brush:.ruby
        :preserve
          vswitch { dpid "0x1" }
          vswitch { dpid "0x2" }
          vswitch { dpid "0x3" }
          vswitch { dpid "0x4" }
            ...

          link "0x1", "0x2"
          link "0x1", "0x3"
          link "0x1", "0x4"
          link "0x1", "0x5"
          link "0x1", "0x6"
          link "0x1", "0x7"
          link "0x1", "0x8"
          link "0x1", "0x9"
          link "0x1", "0x10"
          link "0x2", "0x3"
          link "0x2", "0x4"
            ...


    .slide
      %h1 Advanced DSL Usage
      %ul
        %li 実は DSL では Ruby の文法がそのまま使える (言語内 DSL)
        %li スイッチ 10 台フルメッシュを 2 重ループで簡潔に書くと次の通り:
      %pre.brush:.ruby
        :preserve
          $nswitch = 10

          1.upto( $nswitch ).each do | sw1 |
            vswitch { dpid sw1.to_hex }

            1.upto( $nswitch ).each do | sw2 |
              link sw1.to_hex, sw2.to_hex if sw1 < sw2
            end
          end
      %p 短くなった!


    .slide
      %h1 フローテーブルを書き換えてみよう
      %p パケットを隣りのスイッチポートに転送するフローエントリを書く
      %pre{:class => "brush: ruby; highlight: [3]"}
        :preserve
          class SimpleController < Controller
            def packet_in dpid, message
              send_flow_mod_add(
                dpid,
                :match => ExactMatch.from( message ),
                :buffer_id => message.buffer_id,
                :actions => ActionOutput.new( message.in_port + 1 )
              )
            end
          end
      %p とても短い


    .slide
      %h1 flow_mod API の比較

      %p Trema
      %pre.brush:.ruby
        :preserve
          send_flow_mod_add(
            dpid,
            :match => ExactMatch.from( message ),
            :buffer_id => message.buffer_id,
            :actions => ActionOutput.new( message.in_port + 1 )
          )

      %p NOX
      %pre.brush:.python
        :preserve
          inst.install_datapath_flow(
            dpid,
            extract_flow(packet),
            CACHE_TIMEOUT, 
            openflow.OFP_FLOW_PERMANENT,
            [[openflow.OFPAT_OUTPUT, [0, prt[0]]]],
            bufid,
            openflow.OFP_DEFAULT_PRIORITY,
            inport,
            buf
          )


    .slide
      %h1 気の効いた API

      %p Exact match が簡単に作れる:

      %pre{:class => "brush: ruby; highlight: [3]"}
        :preserve
          send_flow_mod_add(
            dpid,
            :match => ExactMatch.from( message ),
            :buffer_id => message.buffer_id,
            :actions => ActionOutput.new( message.in_port + 1 )
          )

      %p まじめに書くとこう:

      %pre.brush:.ruby
        :preserve
          :match => Match.new(
            :in_port = message.in_port,
            :nw_src => message.nw_src,
            :nw_dst => message.nw_dst,
            :tp_src => message.tp_src,
            :tp_dst => message.tp_dst,
            :dl_src => message.dl_src,
            :dl_dst => message.dl_dst,
              ...
          )


    .slide
      %h1 ベンチマーク (cbench) を実行
      %p cbench: 一秒あたりの flow_mod 数を計測するベンチマーク
      %pre.brush:.plain
        :preserve
          1   switches: fmods/sec:  10627   total = 10.626989 per ms 
          1   switches: fmods/sec:  8184   total = 8.183992 per ms 
          1   switches: fmods/sec:  7542   total = 7.541992 per ms 
          1   switches: fmods/sec:  7852   total = 7.851992 per ms 
          1   switches: fmods/sec:  8243   total = 8.242992 per ms 
          1   switches: fmods/sec:  7807   total = 7.806977 per ms 
          1   switches: fmods/sec:  8484   total = 8.483992 per ms 
          1   switches: fmods/sec:  8401   total = 8.400992 per ms 
          1   switches: fmods/sec:  8129   total = 8.128992 per ms 
          1   switches: fmods/sec:  7853   total = 7.852788 per ms 
          RESULT: 1 switches 9 tests min/max/avg/stdev = 7541.99/8483.99/8054.97/292.12 responses/s
      %p 約 8,000 フローセットアップ/秒


    .slide
      %h1 参考: C で書いた場合
      %p 約 14,000 フローセットアップ/秒
      %pre.brush:.plain
        :preserve
          1   switches: fmods/sec:  8891   total = 8.890991 per ms 
          1   switches: fmods/sec:  14864   total = 14.863985 per ms 
          1   switches: fmods/sec:  14316   total = 14.315986 per ms 
          1   switches: fmods/sec:  14548   total = 14.547985 per ms 
          1   switches: fmods/sec:  14648   total = 14.647956 per ms 
          1   switches: fmods/sec:  13318   total = 13.317987 per ms 
          1   switches: fmods/sec:  14376   total = 14.375986 per ms 
          1   switches: fmods/sec:  13143   total = 13.142987 per ms 
          1   switches: fmods/sec:  14275   total = 14.274986 per ms 
          1   switches: fmods/sec:  14280   total = 14.279986 per ms 
          RESULT: 1 switches 9 tests min/max/avg/stdev = 13142.99/14863.99/14196.43/549.16 responses/s
      %p 最初は Ruby でサッと書いて、必要に応じて C で書き直すのがおすすめ


    .slide
      %h1 Coding Challenge #3: Traffic Monitor


    .slide
      %h1 FDB Class
      %pre.brush:.ruby
        :preserve
          class FDB
            def initialize
              @db = {}
            end

            def lookup mac
              if @db[ mac ]
                @db[ mac ][ :port_number ]
              else
                nil
              end
            end

            def learn mac, port_number
              if @db[ mac ]
                @db[ mac ][ :port_number ] = port_number
              else
                @db[ mac ] = { :mac => mac, :port_number => port_number }
              end
            end
          end


    .slide
      %h1 FDB Class
      %pre.brush:.ruby
        :preserve
          irb(main):001:0> require "fdb"
          => true

          irb(main):002:0> fdb = FDB.new
          => #&lt;FDB:0xb73591e0 @db={}>

          irb(main):003:0> fdb.lookup "00:00:00:00:00:01"
          => nil

          irb(main):004:0> fdb.learn "00:00:00:00:00:01", 1
          => {:mac=>"00:00:00:00:00:01", :port_number=>1}

          irb(main):005:0> fdb.lookup "00:00:00:00:00:01"
          => 1

          irb(main):006:0> fdb.learn "00:00:00:00:00:02", 2
          => {:mac=>"00:00:00:00:00:02", :port_number=>2}

          irb(main):007:0> fdb.lookup "00:00:00:00:00:02"
          => 2


    .slide
      %h1 Counter クラス
      %pre.brush:.ruby
        :preserve
          class Counter
            def initialize
              @db = {}
            end

            def add mac, packet_count, byte_count
              @db[ mac ] ||= { :packet_count => 0, :byte_count => 0 }
              @db[ mac ][ :packet_count ] += packet_count
              @db[ mac ][ :byte_count ] += byte_count
            end

            def each_pair &block
              @db.each_pair &block
            end
          end


    .slide
      %h1 Counter クラス
      %pre.brush:.ruby
        :preserve
          irb(main):001:0> require "counter"
          => true

          irb(main):002:0> counter = Counter.new
          => #<Counter:0xb7366d2c @db={}>

          irb(main):003:0> counter.add "00:00:00:00:00:01", 1, 100
          => 100

          irb(main):004:0> counter.add "00:00:00:00:00:02", 1, 100
          => 100

          irb(main):005:0> counter.add "00:00:00:00:00:02", 1, 100
          => 200

          irb(main):006:0> counter.each_pair do | mac, counter |
          irb(main):007:1*   p counter
          irb(main):008:1> end
          {:packet_count=>1, :byte_count=>100}
          {:packet_count=>2, :byte_count=>200}
          => {"00:00:00:00:00:01"=>{:packet_count=>1, :byte_count=>100}, "00:00:00:00:00:02"=>{:packet_count=>2, :byte_count=>200}}


    .slide
      %h1 TrafficMonitor クラス
      %pre.brush:.ruby
        :preserve
          require "counter"
          require "fdb"

          class TrafficMonitor < Controller
            periodic_timer_event :show_counter, 10

            def start
              # カウンタと FDB を初期化
            end

            def packet_in datapath_id, message
              # L2 スイッチング処理
            end

            def flow_removed datapath_id, message
              # カウンタにパケット数とバイト数を加算
            end

            private
              ...


    .slide
      %h1 TrafficMonitor クラス
      %p TODO: 動かせるとこでは動かしとく


    .slide
      %h1 問題: TrafficMonitor#start
      %pre.brush:.ruby
        :preserve
          class TrafficMonitor < Controller
            ...

            # カウンタと FDB を初期化
            def start
              @counter = __________
              @fdb = _______
            end


    .slide
      %h1 答え: TrafficMonitor#start
      %pre.brush:.ruby
        :preserve
          class TrafficMonitor < Controller
            ...

            # カウンタと FDB を初期化
            def start
              @counter = Counter.new
              @fdb = FDB.new
            end


    .slide
      %h1 TrafficMonitor#packet_in
      %p L2 スイッチングをする
      %p TODO: シーケンス図で説明


    .slide
      %h1 問題: TrafficMonitor#packet_in
      %pre.brush:.ruby
        :preserve
          class TrafficMonitor < Controller
            ...

            def packet_in datapath_id, message
              macsa = message.macsa
              macda = message.macda

              @fdb.learn _____, message.in_port
              @counter.add macsa, 1, message.total_len
              out_port = @fdb.lookup( _____ )
              if out_port
                packet_out datapath_id, message, out_port
                flow_mod datapath_id, macsa, macda, out_port
              else
                flood datapath_id, message
              end


    .slide
      %h1 答え: TrafficMonitor#packet_in
      %pre.brush:.ruby
        :preserve
          class TrafficMonitor < Controller
            ...

            def packet_in datapath_id, message
              macsa = message.macsa
              macda = message.macda

              @fdb.learn macsa, message.in_port
              @counter.add macsa, 1, message.total_len
              out_port = @fdb.lookup( macda )
              if out_port
                packet_out datapath_id, message, out_port
                flow_mod datapath_id, macsa, macda, out_port
              else
                flood datapath_id, message
              end


    .slide
      %h1 問題: TrafficMonitor#flow_removed
      %pre.brush:.ruby
        :preserve
          class TrafficMonitor < Controller
            ...

          def flow_removed datapath_id, message
            @counter.add(
              message.match.dl_src,
              message.____________,
              message.__________
            )
          end


    .slide
      %h1 答え: TrafficMonitor#flow_removed
      %pre.brush:.ruby
        :preserve
          class TrafficMonitor < Controller
            ...

          def flow_removed datapath_id, message
            @counter.add(
              message.match.dl_src,
              message.packet_count,
              message.byte_count
            )
          end


    .slide
      %h1 問題: TrafficMonitor#flow_mod
      %pre.brush:.ruby
        :preserve
          class TrafficMonitor < Controller
              ...

            private
              ...

            def flow_mod datapath_id, macsa, macda, out_port
              send_flow_mod_add(
                datapath_id,
                :hard_timeout => 10,
                :match => Match.new(:dl_src => _____, :dl_dst => _____),
                :actions => Trema::ActionOutput.new( ________ )
              )
            end


    .slide
      %h1 答え: TrafficMonitor#flow_mod
      %pre.brush:.ruby
        :preserve
          class TrafficMonitor < Controller
              ...

            private
              ...

            def flow_mod datapath_id, macsa, macda, out_port
              send_flow_mod_add(
                datapath_id,
                :hard_timeout => 10,
                :match => Match.new(:dl_src => macsa, :dl_dst => macda),
                :actions => Trema::ActionOutput.new( out_port )
              )
            end


    .slide
      %h1 send_flow_mod_add()
      %pre.brush:.ruby
        :preserve
          send_flow_mod_add(
            dpid,
            :match => ExactMatch.from( message ),
            :buffer_id => message.buffer_id,
            actions => ActionOutput.new( message.in_port + 1 )
          )

      %p vs.

      %pre.brush:.c
        :preserve
          // C で同じ処理をした場合
          buffer *flow_mod = create_flow_mod(
            get_transaction_id(),
            match,
            get_cookie(),
            OFPFC_ADD,
            0,
            0,
            UINT16_MAX,
            message.buffer_id,
            OFPP_NONE,
            0,
            actions
          );
          send_openflow_message( datapath_id, flow_mod );


    .slide
      %h1 問題: TrafficMonitor#packet_out
      %pre.brush:.ruby
        :preserve

          class TrafficMonitor < Controller
              ...

            private
              ...

            def packet_out datapath_id, message, out_port
              send_packet_out(
                datapath_id,
                :data => message.____,
                :actions => Trema::ActionOutput.new( _______ )
              )
            end


    .slide
      %h1 答え: TrafficMonitor#packet_out
      %pre.brush:.ruby
        :preserve

          class TrafficMonitor < Controller
              ...

            private
              ...

            def packet_out datapath_id, message, out_port
              send_packet_out(
                datapath_id,
                :data => message.data,
                :actions => Trema::ActionOutput.new( out_port )
              )
            end


    .slide
      %p TODO: C で packet_out やる場合と比較


    .slide
      %h1 問題: TrafficMonitor#flood
      %pre.brush:.ruby
        :preserve

          class TrafficMonitor < Controller
              ...

            private
              ...

            def packet_out datapath_id, message, out_port
              send_packet_out(
                datapath_id,
                :data => message.data,
                :actions => Trema::ActionOutput.new( out_port )
              )
            end

            def flood datapath_id, message
              packet_out datapath_id, message, __________
            end


    .slide
      %h1 答え: TrafficMonitor#flood
      %pre.brush:.ruby
        :preserve

          class TrafficMonitor < Controller
              ...

            private
              ...

            def packet_out datapath_id, message, out_port
              send_packet_out(
                datapath_id,
                :data => message.data,
                :actions => Trema::ActionOutput.new( out_port )
              )
            end

            def flood datapath_id, message
              packet_out datapath_id, message, OFPP_FLOOD
            end


    .slide
      %h1 TrafficMonitor の動かしかた
      %p TODO


    .slide
      %h1 サンプルアプリの紹介
      %ul
        %li Trema には大小さまざまなサンプルアプリが付属 (Ruby, C 両方)
        %li ひととおり動かしてソースを読むことをおすすめします
      %pre.brush:.plain
        :preserve
          % ls src/examples
          cbench_switch          dumper            hash_bench
          hello_trema            learning_switch   list_switches
          multi_learning_switch  openflow_message  packet_in
          repeater_hub           switch_info       switch_monitor
          traffic_monitor


    .slide
      %h1 trema/apps
      %p
        %a{:href => "https://github.com/trema/apps"}https://github.com/trema/apps
      %p Trema で書かれた「マジなアプリ」集
      %ul
        %li ルーティングスイッチ
        %li ロードバランサ
        %li トポロジマネージャ などなど...


    .slide
      %h1 ユニットテスト
      %ul
        %li ホスト間でのパケットの送受信数、スイッチのフローテーブルの中身などを RSpec でユニットテスト可能
        %li 来月の Software Design 連載で詳しく紹介します!


    .slide
      %h1 ユニットテストの例
      %pre.brush:.ruby
        :preserve
          describe RepeaterHub do
            around do | example |
              network {  # ネットワークの定義
                vswitch("switch") { datapath_id "0xabc" }
                vhost("host1") { promisc "on" }
                vhost("host2") { promisc "on" }
                link "switch", "host1"
                link "switch", "host2"
              }.run( RepeaterHub ) {
                example.run
              }
            end

            context "when host1 sends one packet to host2" do
              describe "switch" do
                before { send_packets "host1", "host2" }
                subject { switch( "switch" ) }
                it { should have( 1 ).flows }
                its( "flows.first.actions" ) { should == "FLOOD" }
              end

                ...


    .slide
      %h1 まとめ
      %p
        %span{:style => "background-color: #ffff00"} OpenFlow フレームワーク Trema
      %ul
        %li OpenFlow のコントローラを短く書けて、すぐ動かせる
        %li コミッタやバグレポート募集中!
        %li
          Software Design で好評連載中!
          %br
          (公式ハッシュタグ
          %a{:href => "http://twitter.com/#!/search/#友太郎"} #友太郎
          )


    .slide
      %h1 情報源
      %ul
        %li
          Trema ホームページ:
          %a{:href => "http://trema.github.com/trema/"} http://trema.github.com/trema/
        %li
          Ruby API ドキュメント:
          %a{:href => "http://rubydoc.info/github/trema/trema/"} http://rubydoc.info/github/trema/trema/
        %li
          Twitter アカウント:
          %a{:href => "http://twitter.com/trema_news"} @trema_news


    .layout{"data-name" => "default"}
      %content
      .footer
        %span.left
          %b Hideyuki Shimonishi, Yasuhito Takamiya, Kazushi Sugyo
        %span.right
          Trema on
          %a{:href => "http://github.com/trema/trema/"} github
        %span.left CHANGE & OFELIA Summer School 2011
        %span.right
          Twitter
          %a{:href => "http://twitter.com/trema_news"} @trema_news


    .layout.nofooter{"data-name" => "alt"}
      %content
