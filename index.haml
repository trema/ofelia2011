!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-equiv" => "Content-Type"}/
    / Slide meta data, remove/edit as you see fit
    %title OpenFlow platform Trema, hands-on session
    %meta{:content => "Yasuhito Takamiya", :name => "author"}/
    %meta{:content => "yasuhito@gmail.com", :name => "email"}/
    %meta{:content => "November 9, 2011", :name => "date"}/
    / Slippy core file and dependencies
    %script{:src => "slippy/src/jquery.min.js", :type => "text/javascript"}
    %script{:src => "slippy/src/jquery.history.js", :type => "text/javascript"}
    %script{:src => "slippy/src/slippy.js", :type => "text/javascript"}
    / Slippy structural styles
    %link{:href => "slippy/src/slippy.css", :rel => "stylesheet", :type => "text/css"}/
    / Trema theme
    %link{:href => "trema.css", :rel => "stylesheet", :type => "text/css"}/
    / Syntax highlighting core file
    %script{:src => "slippy/src/highlighter/shCore.js", :type => "text/javascript"}
    / Syntax highlighting brushes, remove those you don't need
    %script{:src => "slippy/src/highlighter/shBrushBash.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushCpp.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushCSharp.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushCss.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushDelphi.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushDiff.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushGroovy.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushJava.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushJScript.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushPhp.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushPlain.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushPython.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushRuby.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushScala.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushSql.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushVb.js", :type => "text/javascript"}
    %script{:src => "slippy/src/highlighter/shBrushXml.js", :type => "text/javascript"}
    / Syntax highlighting styles
    %link{:href => "slippy/src/highlighter/shCore.css", :rel => "stylesheet", :type => "text/css"}/
    %link{:href => "slippy/src/highlighter/shThemeDefault.css", :rel => "stylesheet", :type => "text/css"}/
    / Slippy init code
    :javascript
      $(function() {
          $(".slide").slippy({
              // settings go here
              // possible values are:
              //  - animLen, duration for default animations (0 = disabled)
              //  - animInForward, receives a slide and animates it
              //  - animInRewind, receives a slide and animates it
              //  - animOutForward, receives a slide and animates it
              //  - animOutRewind, receives a slide and animates it
              //  - baseWidth, defines the base for img resizing, if you don't want only
              //    full-width images, specify this as the pixel width of a slide so that
              //    images are scaled properly (default is 620px wide)
              //  - ratio, defines the width/height ratio of the slides, defaults to 1.3 (620x476)
              //  - margin, the fraction of screen to use as slide margin, defaults to 0.15
          });
          SyntaxHighlighter.all();
      });
    / Custom style for this deck
    :css
      .slide.nofooter {
        border: 0;
        background: 0;
      }
  %body


    .slide
      .vcenter
        %h2 OpenFlow platform Trema
        %h2 Hands-on session
        %br
        %br
        %br
        %p
          Hideyuki Shimonishi
          %a{:href => "http://twitter.com/hide_shimonishi"} @hide_shimonishi
          %br
          Yasuhito Takamiya
          %a{:href => "http://twitter.com/yasuhito"} @yasuhito
          %br
          Kazushi Sugyo
          %br
          NEC
          %br
          %br
          %p CHANGE & OFELIA Summer School
          %p November 9, 2011


    .slide
      %h1 We are...
      %p Trema team from NEC laboratories
      %ul
        %li Hideyuki (Networking Ninja)
        %li Yasuhito (HPC and Middleware)
        %li Kazushi (KAME: IPv6 stack for *BSD)


    .slide
      %h1 Q: Why Framework?
      %p
        %b A: High productivity (e.g., Rails, Sinatra)
      %ul
        %li "common operations" can be written in short
        %li Full-stack: develop with your laptop
        %li Tight loops of "coding, testing, and debugging"
      %br
      %p
        %span{:style => "background-color: #ffff00"} ...And there were no such programming framework in OpenFlow yet.


    .slide
      %h1 Features of Trema Framework
      %p
        %span{:style => "background-color: #ffff00"} Most "modern" framework for OpenFlow
      %ul
        %li Ruby or C (Ruby's productivity + C's speed)
        %li Full-stack: develop with your laptop
        %li Open development process on github (GPL2)


    .slide
      %h1 Voices from Exparts
      %p
        %i "I poked through Trema recently.  It looks like a *great* project. Very clean."
        %i (openflow-discuss list)
      .right
        %p Martin Casado (Nicira CTO)


    .slide
      %h1 Trema Design Concept
      .vcenter
        %h1 "Write it short, run it quickly"


    .slide
      %h1 Trema Design Concept
      .vcenter
        %h1
          "
          %span{:style => "background-color: #ffff00"}Write it short,
          run it quickly"


    .slide
      %h1 Why short code?
      %p If you can keep your code short,
      %ul
        %li more quickly you can finish coding,
        %li less incidence of software bug,
        %li and easier to maintainance your code.

        
    .slide
      %h1 Example: Trema repeater-hub
      %pre{:class => "brush: ruby; highlight: [3, 8]"}
        :preserve
          class RepeaterHub < Controller
            def packet_in datapath_id, message
              send_flow_mod_add(
                datapath_id,
                :match => ExactMatch.from( message ),
                :actions => ActionOutput.new( OFPP_FLOOD )
              )
              send_packet_out(
                datapath_id,
                :packet_in => message,
                :actions => ActionOutput.new( OFPP_FLOOD )
              )
            end
          end
      %p
        Only needs essential methods in this code.
        %br
        (flow_mod then FLOOD)


    .slide
      %h1 Let's compare Trema with
      %ul
        %li NOX (Python binding)
        %li Beacon (Java)


    .slide
      %h1 NOX (Python binding)
      %p Redundant code!
      %pre{:class => "brush: python; highlight: [2, 8, 17]"}
        :preserve
          class pyswitch(Component):
              def __init__(self, ctxt):
                  global inst
                  Component.__init__(self, ctxt)
                  self.st = {}
                  inst = self

              def install(self):
                  inst.register_for_packet_in(packet_in_callback)
                  inst.register_for_datapath_leave(datapath_leave_callback)
                  inst.register_for_datapath_join(datapath_join_callback)
                  inst.post_callback(1, timer_callback)

              def getInterface(self):
                  return str(pyswitch)

              def getFactory():
                  class Factory:
                      def instance(self, ctxt):
                          return pyswitch(ctxt)
                  return Factory()


    .slide
      %h1 Beacon (Java)
      %p We dislike Java (static typing system WITHOUT good type inference mechanism makes your code looong!)
      %div{:align => "center"}
        %img{:src => "./static-typing.gif", :height => "60%"}/


    .slide
      %h1 Trema Design Concept
      .vcenter
        %h1
          "Write it short,
          %span{:style => "background-color: #ffff00"} run it quickly
          "


    .slide
      %h1 Pain of OpenFlow development
      %p
        %i "It is complicated to setup OpenFlow development environment (network configurations and VM installations etc.)"

      %br

      %p
        %i "I don't have a OpenFlow switch."

      %br

      %p
        %i "In the first place, I don't have a network usable for OpenFlow experiments."

      .right
        %p Anonymous programmer


    .slide
      %h1 Trema Works with No Pain
      %p
        You can build a virtual network on your laptop and test your own controllers on it.
      %ul
        %li Run your controller without modifications
        %li Send and receive test packets between virtual hosts
        %li Dump switch flow-tables etc.

      %br

      %p.right See how it works...
        

    .slide
      .vcenter
        %h1 Common work flow of development with Trema


    .slide
      %h1 Let's setup Trema!
      %pre.brush:.plain
        :preserve
          $ git clone git://github.com/trema/trema.git
          $ ./trema/build.rb
      %p And there are no step three!


    .slide
      %h1 It's Shakyo Time!

      %span.right
        %img{:src => "./shakyo.jpg", :height => "20%"}/

      %ul
        %li
          Open a file with your favorite editor and let's
          %b shyakyo
          the following code.
        %li Shyakyo = The Japanese form of sutra transcription
        %li Just type it as is ... don't think at first, the details are described later.

      %span.right
        %small The image was taken from http://bit.ly/tI6OXP


    .slide
      %h1 Syakyo #1: Your first controller
      %p Define a controller as a class and make it derived from Controller class
      %pre.brush:.ruby
        :preserve
          # simple.rb

          class SimpleController < Controller
          end
      %br

      %p Run it with "trema run" command:
      %pre.brush:.plain
        :preserve
          % ./trema run ./simple.rb


    .slide
      %h1 Syakyo #2: Hello Trema!
      %ul
        %li Add start method to the controller class.
        %li The method is a hook method invoked at startup (initializer).
      %pre{:class => "brush: ruby; highlight: [3,4,5]"}
        :preserve
          # hello.rb
          class HelloController < Controller
            def start
              puts "Hello, Trema!"
            end
          end

      %p Then you can run it with "trema run"
      %pre{:class => "brush: ruby; highlight: [2]"}
        :preserve
          % ./trema run ./hello.rb
          Hello, Trema!


    .slide
      %h1 Ruby in one minute
      %h2 Class definition
      %pre.brush:.ruby
        :preserve
          class ClassName < SuperClassName
            def method_name arg1, arg2
              # method body
            end
          end


    .slide
      %h1 Syakyo #3: Switch Monitor
      %p Switch monitor controller spec:
      %ul
        %li Update the list of switches in real-time
        %li Notifies when a new switch is UP
        %li Notifies when a switch become DOWN


    .slide
      %h1 Syakyo #3: Switch Monitor
      %pre.brush:.ruby
        :preserve
          # src/examples/switch_monitor/switch-monitor.rb
          class SwitchMonitor < Controller
            periodic_timer_event :show_switches, 10

            def start
              @switches = []
            end

            def switch_ready datapath_id
              @switches << datapath_id.to_hex
              info "Switch \#{ datapath_id.to_hex } is UP"
            end

            def switch_disconnected datapath_id
              @switches -= [ datapath_id.to_hex ]
              info "Switch \#{ datapath_id.to_hex } is DOWN"
            end

            private

            def show_switches
              info "All switches = " + @switches.sort.join( ", " )
            end
          end


    .slide
      %h1 Event Handlers
      %pre{:class => "brush: ruby; highlight: [9,14]"}
        :preserve
          class SwitchMonitor < Controller
            periodic_timer_event :show_switches, 10

            def start
              @switches = []
            end

            def switch_ready datapath_id
              @switches << datapath_id.to_hex
              info "Switch \#{ datapath_id.to_hex } is UP"
            end

            def switch_disconnected datapath_id
              @switches -= [ datapath_id.to_hex ]
              info "Switch \#{ datapath_id.to_hex } is DOWN"
            end

            private

            def show_switches
              info "All switches = " + @switches.sort.join( ", " )
            end
          end


    .slide
      %h1 switch_ready handler
      %pre{:class => "brush: ruby; highlight: [8,9,10,11]"}
        :preserve
          class SwitchMonitor < Controller
            periodic_timer_event :show_switches, 10

            def start
              @switches = []
            end

            def switch_ready datapath_id
              @switches << datapath_id.to_hex
              info "Switch \#{ datapath_id.to_hex } is UP"
            end
      %ul
        %li When a switch is connected to the controller, add its dpid to the switch-list instance variable (@switches)
        %li Output like "Switch 0xabc is UP"


    .slide
      %h1 List in Ruby
      %pre.brush:.ruby
        :preserve
          % irb
          > zoo = []
          => []

          > zoo << "bat"
          => ["bat"]

          > zoo << "gnu"
          => ["bat", "gnu"]

          > zoo << "dog"
          => ["bat", "gnu", "dog"]

          > zoo -= ["bat"]
          => ["gnu", "dog"]

          > zoo.sort
          => ["dog", "gnu"]
      %p irb = interactive ruby (REPL)


    .slide
      %h1 Variable and String in Ruby
      %pre.brush:.ruby
        :preserve
          % irb
          > name = "Spider-Man"
          => "Spider-Man"

          > puts "My name is \#{ name }"
          My name is Spider-Man
          => nil


    .slide
      %h1 switch_disconnected handler
      %ul
        %li When a switch become DOWN, remove its dpid from @switches list
        %li Output like "Switch 0xabc is DOWN"
      %pre{:class => "brush: ruby; highlight: [6,7,8,9]"}
        :preserve
          # src/examples/switch_monitor/switch-monitor.rb
          class SwitchMonitor < Controller

              ...

            def switch_disconnected datapath_id
              @switches -= [ datapath_id.to_hex ]
              info "Switch \#{ datapath_id.to_hex } is DOWN"
            end

              ...



    .slide
      %h1 show_switches timer handler
      %ul
        %li Output the switch list like "All switches = 0xabc, 0xdef, ..." in every 10 seconds
        %li periodic_timer_handler registers show_switches method as a timer handler
      %pre{:class => "brush: ruby; highlight: [2,6,7,8]"} 
        :preserve
          class SwitchMonitor < Controller
            periodic_timer_event :show_switches, 10

              ...

            def show_switches
              info "All switches = " + @switches.sort.join( ", " )
            end
          end


    .slide
      %h1 Run Switch Monitor

      %p Write a virtual network configuration (DSL) that adds three switches to the network.
      %pre.brush:.ruby
        :preserve
          # switch-monitor.conf
          vswitch { datapath_id 0x1 }
          vswitch { datapath_id 0x2 }
          vswitch { datapath_id 0x3 }

      %p Then pass it to trema run with -c option
      %pre.brush:.plain
        :preserve
          % ./trema run ./switch-monitor.rb -c ./switch-monitor.conf
          Switch 0x3 is UP
          Switch 0x2 is UP
          Switch 0x1 is UP
          All switches = 0x1, 0x2, 0x3
          All switches = 0x1, 0x2, 0x3
          All switches = 0x1, 0x2, 0x3
            ...


    .slide
      %h1 Virtual Network DSL
      %ul
        %li You can build arbitrally network topology on your laptop and run your controlller on it.
        %li Debug your controller by sending and receiving test packets between virtual hosts.
        %li You can use virtual switch, host, and link to construct the virtual network.


    .slide
      %h1 Kill a Switch Intentionally

      %p Open another terminal and run "trema kill"
      %pre.brush:.bash
        :preserve
          % ./trema kill 0x3

      %p Then you can see "Switch 0x??? is DOWN" on the "trema run" terminal
      %pre{:class => "brush: ruby; highlight: [9]"} 
        :preserve
          % ./trema run ./switch-monitor.rb -c ./switch-monitor.conf
          Switch 0x3 is UP
          Switch 0x2 is UP
          Switch 0x1 is UP
          All switches = 0x1, 0x2, 0x3
          All switches = 0x1, 0x2, 0x3
          All switches = 0x1, 0x2, 0x3
            ...
          Switch 0x3 is DOWN


    .slide
      %h1 Summary: Switch Monitor
      %ul
        %li Implement the logic of a controller by defining event handler methods (e.g., switch_ready, switch_disconnected etc.)
        %li Network DSL makes it possible to test your own controller even if you don't have an OpenFlow switch.


    .slide
      %h1 Syakyo #4: packet-in handling
      %p Add the following method to handle packet-in
      %pre{:class => "brush: ruby; highlight: [2,3,4]"}
        :preserve
          class SimpleController < Controller
            def packet_in dpid, message
              puts "New packet_in message!"
            end
              ...
      %ul
        %li dpid: the datapath ID of the switch that received a packet-in
        %li message: packet-in message object


    .slide
      %h1 Let's Send Packets!
      %p Firstly, you must add virtual hosts to send/receive packets and connect them to a virtual switch:
      %pre.brush:.ruby
        :preserve
          vswitch { dpid 0xabc }

          # Add two virtual hosts
          vhost("host1") {
            mac "00:00:00:00:00:01"
          }
          vhost("host2") {
            mac "00:00:00:00:00:02"
          }

          # connect hosts to a switch
          link "0xabc", "host1"
          link "0xabc", "host2"


    .slide
      %h1 Let's Send Packets!
      %ul
        %li Send test packets with send_packets
        %li For example the following will send ten packets from host1 to host2
      %pre.brush:.plain
        :preserve
          % ./trema send_packets --source host1 --dest host2 --n_pkts 10 --pps 10
          New packet_in message!
          New packet_in message!
          New packet_in message!
          New packet_in message!
          New packet_in message!
          New packet_in message!
          New packet_in message!
          New packet_in message!
          New packet_in message!
          New packet_in message!
      %p packet_in handler is called ten times


    .slide
      %h1 大規模で複雑なトポロジ
      %p スイッチ 10 台のフルメッシュ接続をベタに書いた例 (約 80 行)
      %pre.brush:.ruby
        :preserve
          vswitch { dpid "0x1" }
          vswitch { dpid "0x2" }
          vswitch { dpid "0x3" }
          vswitch { dpid "0x4" }
            ...

          link "0x1", "0x2"
          link "0x1", "0x3"
          link "0x1", "0x4"
          link "0x1", "0x5"
          link "0x1", "0x6"
          link "0x1", "0x7"
          link "0x1", "0x8"
          link "0x1", "0x9"
          link "0x1", "0x10"
          link "0x2", "0x3"
          link "0x2", "0x4"
            ...


    .slide
      %h1 Advanced DSL Usage
      %ul
        %li 実は DSL では Ruby の文法がそのまま使える (言語内 DSL)
        %li スイッチ 10 台フルメッシュを 2 重ループで簡潔に書くと次の通り:
      %pre.brush:.ruby
        :preserve
          $nswitch = 10

          1.upto( $nswitch ).each do | sw1 |
            vswitch { dpid sw1.to_hex }

            1.upto( $nswitch ).each do | sw2 |
              link sw1.to_hex, sw2.to_hex if sw1 < sw2
            end
          end
      %p 短くなった!


    .slide
      %h1 フローテーブルを書き換えてみよう
      %p パケットを隣りのスイッチポートに転送するフローエントリを書く
      %pre{:class => "brush: ruby; highlight: [3]"}
        :preserve
          class SimpleController < Controller
            def packet_in dpid, message
              send_flow_mod_add(
                dpid,
                :match => ExactMatch.from( message ),
                :buffer_id => message.buffer_id,
                :actions => ActionOutput.new( message.in_port + 1 )
              )
            end
          end
      %p とても短い


    .slide
      %h1 flow_mod API の比較

      %p Trema
      %pre.brush:.ruby
        :preserve
          send_flow_mod_add(
            dpid,
            :match => ExactMatch.from( message ),
            :buffer_id => message.buffer_id,
            :actions => ActionOutput.new( message.in_port + 1 )
          )

      %p NOX
      %pre.brush:.python
        :preserve
          inst.install_datapath_flow(
            dpid,
            extract_flow(packet),
            CACHE_TIMEOUT, 
            openflow.OFP_FLOW_PERMANENT,
            [[openflow.OFPAT_OUTPUT, [0, prt[0]]]],
            bufid,
            openflow.OFP_DEFAULT_PRIORITY,
            inport,
            buf
          )


    .slide
      %h1 気の効いた API

      %p Exact match が簡単に作れる:

      %pre{:class => "brush: ruby; highlight: [3]"}
        :preserve
          send_flow_mod_add(
            dpid,
            :match => ExactMatch.from( message ),
            :buffer_id => message.buffer_id,
            :actions => ActionOutput.new( message.in_port + 1 )
          )

      %p まじめに書くとこう:

      %pre.brush:.ruby
        :preserve
          :match => Match.new(
            :in_port = message.in_port,
            :nw_src => message.nw_src,
            :nw_dst => message.nw_dst,
            :tp_src => message.tp_src,
            :tp_dst => message.tp_dst,
            :dl_src => message.dl_src,
            :dl_dst => message.dl_dst,
              ...
          )


    .slide
      %h1 ベンチマーク (cbench) を実行
      %p cbench: 一秒あたりの flow_mod 数を計測するベンチマーク
      %pre.brush:.plain
        :preserve
          1   switches: fmods/sec:  10627   total = 10.626989 per ms 
          1   switches: fmods/sec:  8184   total = 8.183992 per ms 
          1   switches: fmods/sec:  7542   total = 7.541992 per ms 
          1   switches: fmods/sec:  7852   total = 7.851992 per ms 
          1   switches: fmods/sec:  8243   total = 8.242992 per ms 
          1   switches: fmods/sec:  7807   total = 7.806977 per ms 
          1   switches: fmods/sec:  8484   total = 8.483992 per ms 
          1   switches: fmods/sec:  8401   total = 8.400992 per ms 
          1   switches: fmods/sec:  8129   total = 8.128992 per ms 
          1   switches: fmods/sec:  7853   total = 7.852788 per ms 
          RESULT: 1 switches 9 tests min/max/avg/stdev = 7541.99/8483.99/8054.97/292.12 responses/s
      %p 約 8,000 フローセットアップ/秒


    .slide
      %h1 参考: C で書いた場合
      %p 約 14,000 フローセットアップ/秒
      %pre.brush:.plain
        :preserve
          1   switches: fmods/sec:  8891   total = 8.890991 per ms 
          1   switches: fmods/sec:  14864   total = 14.863985 per ms 
          1   switches: fmods/sec:  14316   total = 14.315986 per ms 
          1   switches: fmods/sec:  14548   total = 14.547985 per ms 
          1   switches: fmods/sec:  14648   total = 14.647956 per ms 
          1   switches: fmods/sec:  13318   total = 13.317987 per ms 
          1   switches: fmods/sec:  14376   total = 14.375986 per ms 
          1   switches: fmods/sec:  13143   total = 13.142987 per ms 
          1   switches: fmods/sec:  14275   total = 14.274986 per ms 
          1   switches: fmods/sec:  14280   total = 14.279986 per ms 
          RESULT: 1 switches 9 tests min/max/avg/stdev = 13142.99/14863.99/14196.43/549.16 responses/s
      %p 最初は Ruby でサッと書いて、必要に応じて C で書き直すのがおすすめ


    .slide
      %h1 Coding Challenge #3: Traffic Monitor


    .slide
      %h1 FDB Class
      %pre.brush:.ruby
        :preserve
          class FDB
            def initialize
              @db = {}
            end

            def lookup mac
              if @db[ mac ]
                @db[ mac ][ :port_number ]
              else
                nil
              end
            end

            def learn mac, port_number
              if @db[ mac ]
                @db[ mac ][ :port_number ] = port_number
              else
                @db[ mac ] = { :mac => mac, :port_number => port_number }
              end
            end
          end


    .slide
      %h1 FDB Class
      %pre.brush:.ruby
        :preserve
          irb(main):001:0> require "fdb"
          => true

          irb(main):002:0> fdb = FDB.new
          => #&lt;FDB:0xb73591e0 @db={}>

          irb(main):003:0> fdb.lookup "00:00:00:00:00:01"
          => nil

          irb(main):004:0> fdb.learn "00:00:00:00:00:01", 1
          => {:mac=>"00:00:00:00:00:01", :port_number=>1}

          irb(main):005:0> fdb.lookup "00:00:00:00:00:01"
          => 1

          irb(main):006:0> fdb.learn "00:00:00:00:00:02", 2
          => {:mac=>"00:00:00:00:00:02", :port_number=>2}

          irb(main):007:0> fdb.lookup "00:00:00:00:00:02"
          => 2


    .slide
      %h1 Counter クラス
      %pre.brush:.ruby
        :preserve
          class Counter
            def initialize
              @db = {}
            end

            def add mac, packet_count, byte_count
              @db[ mac ] ||= { :packet_count => 0, :byte_count => 0 }
              @db[ mac ][ :packet_count ] += packet_count
              @db[ mac ][ :byte_count ] += byte_count
            end

            def each_pair &block
              @db.each_pair &block
            end
          end


    .slide
      %h1 Counter クラス
      %pre.brush:.ruby
        :preserve
          irb(main):001:0> require "counter"
          => true

          irb(main):002:0> counter = Counter.new
          => #<Counter:0xb7366d2c @db={}>

          irb(main):003:0> counter.add "00:00:00:00:00:01", 1, 100
          => 100

          irb(main):004:0> counter.add "00:00:00:00:00:02", 1, 100
          => 100

          irb(main):005:0> counter.add "00:00:00:00:00:02", 1, 100
          => 200

          irb(main):006:0> counter.each_pair do | mac, counter |
          irb(main):007:1*   p counter
          irb(main):008:1> end
          {:packet_count=>1, :byte_count=>100}
          {:packet_count=>2, :byte_count=>200}
          => {"00:00:00:00:00:01"=>{:packet_count=>1, :byte_count=>100}, "00:00:00:00:00:02"=>{:packet_count=>2, :byte_count=>200}}


    .slide
      %h1 TrafficMonitor クラス
      %pre.brush:.ruby
        :preserve
          require "counter"
          require "fdb"

          class TrafficMonitor < Controller
            periodic_timer_event :show_counter, 10

            def start
              # カウンタと FDB を初期化
            end

            def packet_in datapath_id, message
              # L2 スイッチング処理
            end

            def flow_removed datapath_id, message
              # カウンタにパケット数とバイト数を加算
            end

            private
              ...


    .slide
      %h1 TrafficMonitor クラス
      %p TODO: 動かせるとこでは動かしとく


    .slide
      %h1 問題: TrafficMonitor#start
      %pre.brush:.ruby
        :preserve
          class TrafficMonitor < Controller
            ...

            # カウンタと FDB を初期化
            def start
              @counter = __________
              @fdb = _______
            end


    .slide
      %h1 答え: TrafficMonitor#start
      %pre.brush:.ruby
        :preserve
          class TrafficMonitor < Controller
            ...

            # カウンタと FDB を初期化
            def start
              @counter = Counter.new
              @fdb = FDB.new
            end


    .slide
      %h1 TrafficMonitor#packet_in
      %p L2 スイッチングをする
      %p TODO: シーケンス図で説明


    .slide
      %h1 問題: TrafficMonitor#packet_in
      %pre.brush:.ruby
        :preserve
          class TrafficMonitor < Controller
            ...

            def packet_in datapath_id, message
              macsa = message.macsa
              macda = message.macda

              @fdb.learn _____, message.in_port
              @counter.add macsa, 1, message.total_len
              out_port = @fdb.lookup( _____ )
              if out_port
                packet_out datapath_id, message, out_port
                flow_mod datapath_id, macsa, macda, out_port
              else
                flood datapath_id, message
              end


    .slide
      %h1 答え: TrafficMonitor#packet_in
      %pre.brush:.ruby
        :preserve
          class TrafficMonitor < Controller
            ...

            def packet_in datapath_id, message
              macsa = message.macsa
              macda = message.macda

              @fdb.learn macsa, message.in_port
              @counter.add macsa, 1, message.total_len
              out_port = @fdb.lookup( macda )
              if out_port
                packet_out datapath_id, message, out_port
                flow_mod datapath_id, macsa, macda, out_port
              else
                flood datapath_id, message
              end


    .slide
      %h1 問題: TrafficMonitor#flow_removed
      %pre.brush:.ruby
        :preserve
          class TrafficMonitor < Controller
            ...

          def flow_removed datapath_id, message
            @counter.add(
              message.match.dl_src,
              message.____________,
              message.__________
            )
          end


    .slide
      %h1 答え: TrafficMonitor#flow_removed
      %pre.brush:.ruby
        :preserve
          class TrafficMonitor < Controller
            ...

          def flow_removed datapath_id, message
            @counter.add(
              message.match.dl_src,
              message.packet_count,
              message.byte_count
            )
          end


    .slide
      %h1 問題: TrafficMonitor#flow_mod
      %pre.brush:.ruby
        :preserve
          class TrafficMonitor < Controller
              ...

            private
              ...

            def flow_mod datapath_id, macsa, macda, out_port
              send_flow_mod_add(
                datapath_id,
                :hard_timeout => 10,
                :match => Match.new(:dl_src => _____, :dl_dst => _____),
                :actions => Trema::ActionOutput.new( ________ )
              )
            end


    .slide
      %h1 答え: TrafficMonitor#flow_mod
      %pre.brush:.ruby
        :preserve
          class TrafficMonitor < Controller
              ...

            private
              ...

            def flow_mod datapath_id, macsa, macda, out_port
              send_flow_mod_add(
                datapath_id,
                :hard_timeout => 10,
                :match => Match.new(:dl_src => macsa, :dl_dst => macda),
                :actions => Trema::ActionOutput.new( out_port )
              )
            end


    .slide
      %h1 send_flow_mod_add()
      %pre.brush:.ruby
        :preserve
          send_flow_mod_add(
            dpid,
            :match => ExactMatch.from( message ),
            :buffer_id => message.buffer_id,
            actions => ActionOutput.new( message.in_port + 1 )
          )

      %p vs.

      %pre.brush:.c
        :preserve
          // C で同じ処理をした場合
          buffer *flow_mod = create_flow_mod(
            get_transaction_id(),
            match,
            get_cookie(),
            OFPFC_ADD,
            0,
            0,
            UINT16_MAX,
            message.buffer_id,
            OFPP_NONE,
            0,
            actions
          );
          send_openflow_message( datapath_id, flow_mod );


    .slide
      %h1 問題: TrafficMonitor#packet_out
      %pre.brush:.ruby
        :preserve

          class TrafficMonitor < Controller
              ...

            private
              ...

            def packet_out datapath_id, message, out_port
              send_packet_out(
                datapath_id,
                :data => message.____,
                :actions => Trema::ActionOutput.new( _______ )
              )
            end


    .slide
      %h1 答え: TrafficMonitor#packet_out
      %pre.brush:.ruby
        :preserve

          class TrafficMonitor < Controller
              ...

            private
              ...

            def packet_out datapath_id, message, out_port
              send_packet_out(
                datapath_id,
                :data => message.data,
                :actions => Trema::ActionOutput.new( out_port )
              )
            end


    .slide
      %p TODO: C で packet_out やる場合と比較


    .slide
      %h1 問題: TrafficMonitor#flood
      %pre.brush:.ruby
        :preserve

          class TrafficMonitor < Controller
              ...

            private
              ...

            def packet_out datapath_id, message, out_port
              send_packet_out(
                datapath_id,
                :data => message.data,
                :actions => Trema::ActionOutput.new( out_port )
              )
            end

            def flood datapath_id, message
              packet_out datapath_id, message, __________
            end


    .slide
      %h1 答え: TrafficMonitor#flood
      %pre.brush:.ruby
        :preserve

          class TrafficMonitor < Controller
              ...

            private
              ...

            def packet_out datapath_id, message, out_port
              send_packet_out(
                datapath_id,
                :data => message.data,
                :actions => Trema::ActionOutput.new( out_port )
              )
            end

            def flood datapath_id, message
              packet_out datapath_id, message, OFPP_FLOOD
            end


    .slide
      %h1 TrafficMonitor の動かしかた
      %p TODO


    .slide
      %h1 サンプルアプリの紹介
      %ul
        %li Trema には大小さまざまなサンプルアプリが付属 (Ruby, C 両方)
        %li ひととおり動かしてソースを読むことをおすすめします
      %pre.brush:.plain
        :preserve
          % ls src/examples
          cbench_switch          dumper            hash_bench
          hello_trema            learning_switch   list_switches
          multi_learning_switch  openflow_message  packet_in
          repeater_hub           switch_info       switch_monitor
          traffic_monitor


    .slide
      %h1 trema/apps
      %p
        %a{:href => "https://github.com/trema/apps"}https://github.com/trema/apps
      %p Trema で書かれた「マジなアプリ」集
      %ul
        %li ルーティングスイッチ
        %li ロードバランサ
        %li トポロジマネージャ などなど...


    .slide
      %h1 ユニットテスト
      %ul
        %li ホスト間でのパケットの送受信数、スイッチのフローテーブルの中身などを RSpec でユニットテスト可能
        %li 来月の Software Design 連載で詳しく紹介します!


    .slide
      %h1 ユニットテストの例
      %pre.brush:.ruby
        :preserve
          describe RepeaterHub do
            around do | example |
              network {  # ネットワークの定義
                vswitch("switch") { datapath_id "0xabc" }
                vhost("host1") { promisc "on" }
                vhost("host2") { promisc "on" }
                link "switch", "host1"
                link "switch", "host2"
              }.run( RepeaterHub ) {
                example.run
              }
            end

            context "when host1 sends one packet to host2" do
              describe "switch" do
                before { send_packets "host1", "host2" }
                subject { switch( "switch" ) }
                it { should have( 1 ).flows }
                its( "flows.first.actions" ) { should == "FLOOD" }
              end

                ...


    .slide
      %h1 まとめ
      %p
        %span{:style => "background-color: #ffff00"} OpenFlow フレームワーク Trema
      %ul
        %li OpenFlow のコントローラを短く書けて、すぐ動かせる
        %li コミッタやバグレポート募集中!
        %li
          Software Design で好評連載中!
          %br
          (公式ハッシュタグ
          %a{:href => "http://twitter.com/#!/search/#友太郎"} #友太郎
          )


    .slide
      %h1 情報源
      %ul
        %li
          Trema ホームページ:
          %a{:href => "http://trema.github.com/trema/"} http://trema.github.com/trema/
        %li
          Ruby API ドキュメント:
          %a{:href => "http://rubydoc.info/github/trema/trema/"} http://rubydoc.info/github/trema/trema/
        %li
          Twitter アカウント:
          %a{:href => "http://twitter.com/trema_news"} @trema_news


    .layout{"data-name" => "default"}
      %content
      .footer
        %span.left
          %b Hideyuki Shimonishi, Yasuhito Takamiya, Kazushi Sugyo
        %span.right
          Trema on
          %a{:href => "http://github.com/trema/trema/"} github
        %span.left CHANGE & OFELIA Summer School 2011
        %span.right
          Twitter
          %a{:href => "http://twitter.com/trema_news"} @trema_news


    .layout.nofooter{"data-name" => "alt"}
      %content
